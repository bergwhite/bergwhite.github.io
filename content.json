[{"title":"Zepto源码分析（一）核心代码分析","date":"2017-08-25T16:55:24.000Z","path":"2017/08/26/Zepto源码分析（一）核心代码分析/","text":"本文只分析核心的部分代码，并且在这部分代码有删减，但是不影响代码的正常运行。 目录 12345678* 用闭包封装Zepto* 开始处理细节* 正式处理数据（获取选择器选择的DOM）* 正式处理数据（添加DOM到当前实例）* 在实例的原型链上添加方法* 支持插件扩展* 验收 用闭包封装Zepto 1234567891011121314151617// 对全局暴露Zepto变量var Zepto = (function() &#123; // 定义$变量，并将具体细节交给zepto.init处理 $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 返回变量 return $&#125;)()// 把Zepto变量挂载在windowwindow.Zepto = Zepto// 当$变量没有被占用的时候，为Zepto设置别名为$window.$ === undefined &amp;&amp; (window.$ = Zepto) 开始处理细节 1234567891011121314151617181920212223242526272829303132// 对全局暴露Zepto变量var Zepto = (function() &#123; // [新增] 初始化zepto变量为对象 var zepto = &#123;&#125; // [新增] 添加初始化方法。当selector参数为空时，则交给zepto.Z()处理 // 当selector为字符串时则把zepto.qsa(document, selector)的值存到dom变量 // 并且交给zepto.Z(dom, selector)处理 zepto.init = function(selector, context) &#123; var dom if (!selector) return zepto.Z() else if (typeof selector == &apos;string&apos;) &#123; dom = zepto.qsa(document, selector) &#125; return zepto.Z(dom, selector) &#125; // 定义$变量，并将具体细节交给zepto.init处理 $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 返回变量 return $&#125;)()// 把Zepto变量挂载在windowwindow.Zepto = Zepto// 当$变量没有被占用的时候，为Zepto设置别名为$window.$ === undefined &amp;&amp; (window.$ = Zepto) 正式处理数据（获取选择器选择的DOM） 12345678910111213141516171819202122232425262728293031323334353637// 对全局暴露Zepto变量var Zepto = (function() &#123; // 初始化zepto变量为对象 var zepto = &#123;&#125; // 添加初始化方法。当selector参数为空时，则交给zepto.Z()处理 // 当selector为字符串时则把zepto.qsa(document, selector)的值存到dom变量 // 并且交给zepto.Z(dom, selector)处理 zepto.init = function(selector, context) &#123; var dom if (!selector) return zepto.Z() else if (typeof selector == &apos;string&apos;) &#123; dom = zepto.qsa(document, selector) &#125; return zepto.Z(dom, selector) &#125; // 定义$变量，并将具体细节交给zepto.init处理 $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // [新增] 使用querySelectorAll(selector)查询DOM zepto.qsa = function(element, selector)&#123; return selector ? element.querySelectorAll(selector) : [] &#125; // 返回变量 return $&#125;)()// 把Zepto变量挂载在windowwindow.Zepto = Zepto// 当$变量没有被占用的时候，为Zepto设置别名为$window.$ === undefined &amp;&amp; (window.$ = Zepto) 正式处理数据（添加DOM到当前实例） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 对全局暴露Zepto变量var Zepto = (function() &#123; // 初始化zepto变量为对象 var zepto = &#123;&#125; // [新增] 开始正式处理数据。当dom长度为0则不添加内容， // 否则逐个将dom逐个到当前实例 function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || &apos;&apos; &#125; // [新增] 直接返回一个新的构造函数 zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; // 添加初始化方法。当selector参数为空时，则交给zepto.Z()处理 // 当selector为字符串时则把zepto.qsa(document, selector)的值存到dom变量 // 并且交给zepto.Z(dom, selector)处理 zepto.init = function(selector, context) &#123; var dom if (!selector) return zepto.Z() else if (typeof selector == &apos;string&apos;) &#123; dom = zepto.qsa(document, selector) &#125; return zepto.Z(dom, selector) &#125; // 定义$变量，并将具体细节交给zepto.init处理 $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 使用querySelectorAll(selector)查询DOM zepto.qsa = function(element, selector)&#123; return selector ? element.querySelectorAll(selector) : [] &#125; // 返回变量 return $&#125;)()// 把Zepto变量挂载在windowwindow.Zepto = Zepto// 当$变量没有被占用的时候，为Zepto设置别名为$window.$ === undefined &amp;&amp; (window.$ = Zepto) 在实例的原型链上添加方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 对全局暴露Zepto变量var Zepto = (function() &#123; // 初始化zepto变量为对象 var zepto = &#123;&#125;, emptyArray = [] // 开始正式处理数据。当dom长度为0则不添加内容， // 否则逐个将dom逐个到当前实例 function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || &apos;&apos; &#125; // 直接返回一个新的构造函数 zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; // 添加初始化方法。当selector参数为空时，则交给zepto.Z()处理 // 当selector为字符串时则把zepto.qsa(document, selector)的值存到dom变量 // 并且交给zepto.Z(dom, selector)处理 zepto.init = function(selector, context) &#123; var dom if (!selector) return zepto.Z() else if (typeof selector == &apos;string&apos;) &#123; dom = zepto.qsa(document, selector) &#125; return zepto.Z(dom, selector) &#125; // 定义$变量，并将具体细节交给zepto.init处理 $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // 使用querySelectorAll(selector)查询DOM zepto.qsa = function(element, selector)&#123; return selector ? element.querySelectorAll(selector) : [] &#125; // [新增] 定义each方法 $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; // [新增] 定义用于扩展在原型链上的方法 $.fn = &#123; constructor: zepto.Z, length: 0, each: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this &#125;, empty: function()&#123; return this.each(function()&#123; this.innerHTML = &apos;&apos; &#125;) &#125;, html: function(html)&#123; return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : (0 in this ? this[0].innerHTML : null) &#125;, test : function()&#123; return this.each(function()&#123; console.log(&apos;测试链式调用&apos;) return this &#125;) &#125; &#125; // [新增] 原型链指向$.fn zepto.Z.prototype = Z.prototype = $.fn // $.zepto指向zepto $.zepto = zepto // 返回变量 return $&#125;)()// 把Zepto变量挂载在windowwindow.Zepto = Zepto// 当$变量没有被占用的时候，为Zepto设置别名为$window.$ === undefined &amp;&amp; (window.$ = Zepto) 支持插件扩展 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 对全局暴露Zepto变量var Zepto = (function() &#123; // 初始化zepto变量为对象 var zepto = &#123;&#125;, emptyArray = [] // 开始正式处理数据。当dom长度为0则不添加内容， // 否则逐个将dom逐个到当前实例 function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || &apos;&apos; &#125; // 直接返回一个新的构造函数 zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; // 添加初始化方法。当selector参数为空时，则交给zepto.Z()处理 // 当selector为字符串时则把zepto.qsa(document, selector)的值存到dom变量 // 并且交给zepto.Z(dom, selector)处理 zepto.init = function(selector, context) &#123; var dom if (!selector) return zepto.Z() else if (typeof selector == &apos;string&apos;) &#123; dom = zepto.qsa(document, selector) &#125; return zepto.Z(dom, selector) &#125; // 定义$变量，并将具体细节交给zepto.init处理 $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; // [新增] 插件扩展函数 function extend(target, source, deep) &#123; for (key in source) if (source[key] !== undefined) target[key] = source[key] &#125; // [新增] 插件扩展函数 $.extend = function(target)&#123; var deep, args = emptyArray.slice.call(arguments, 1) if (typeof target == &apos;boolean&apos;) &#123; deep = target target = args.shift() &#125; args.forEach(function(arg)&#123; extend(target, arg, deep) &#125;) return target &#125; // 使用querySelectorAll(selector)查询DOM zepto.qsa = function(element, selector)&#123; return selector ? element.querySelectorAll(selector) : [] &#125; // 定义each方法 $.each = function(elements, callback)&#123; var i, key if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements &#125; return elements &#125; // 定义用于扩展在原型链上的方法 $.fn = &#123; constructor: zepto.Z, length: 0, each: function(callback)&#123; emptyArray.every.call(this, function(el, idx)&#123; return callback.call(el, idx, el) !== false &#125;) return this &#125;, empty: function()&#123; return this.each(function()&#123; this.innerHTML = &apos;&apos; &#125;) &#125;, html: function(html)&#123; return 0 in arguments ? this.each(function(idx)&#123; var originHtml = this.innerHTML $(this).empty().append( funcArg(this, html, idx, originHtml) ) &#125;) : (0 in this ? this[0].innerHTML : null) &#125;, test : function()&#123; return this.each(function()&#123; console.log(&apos;测试链式调用&apos;) return this &#125;) &#125; &#125; // 原型链指向$.fn zepto.Z.prototype = Z.prototype = $.fn // $.zepto指向zepto $.zepto = zepto // 返回变量 return $&#125;)()// 把Zepto变量挂载在windowwindow.Zepto = Zepto// 当$变量没有被占用的时候，为Zepto设置别名为$window.$ === undefined &amp;&amp; (window.$ = Zepto) 验收 1234567891011121314// 链式调用测试$(&apos;head&apos;).test().test() // 测试链式调用\\n测试链式调用\\n&#123;0: head, length: 1, selector: &quot;head&quot;&#125;$(&apos;head&apos;).html() // &lt;meta charset=&quot;utf-8&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href...// 编写插件测试;(function($)&#123; $.extend($.fn, &#123; bw2: function() &#123; return this.html() &#125; &#125;)&#125;)(Zepto)$(&apos;head&apos;).bw2() // &lt;meta charset=&quot;utf-8&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href... 欢迎关注前端进阶指南微信公众号： 另外我也创了一个对应的QQ群：660112451，欢迎一起交流。","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"React版V2EX社区（react & react-router & axios & antd ui）","date":"2017-08-22T04:31:23.000Z","path":"2017/08/22/React版V2EX社区（react & react-router & axios & antd ui）/","text":"目录 项目简介 在线演示 截图演示 踩坑 项目简介（1/4） Github: https://github.com/bergwhite/v2ex-react 项目使用React、Reac-router、Axios、ANTD UI进行开发 项目兼容移动端 使用Nginx代理V2EX API并支持CORS跨域 另外还写过一个Vue版V2EX项目，v2ex-vue：https://x.bw2.me/#/ 以及nodejs聊天室，nchat：http://y.bw2.me:8086 找工作，北京。联系方式：YmVyZ3doaXRlc0BnbWFpbC5jb20= 觉得对你有帮助的话，欢迎给个star，谢谢 在线演示（2/4） 点击进入 另外还用cordova打包成了安卓APK 截图演示（3/4）导航页面 文章页面 分类页面 用户和主题页面 踩坑（4/4）支持IE在IE中的报错，TypeError: 对象不支持“startsWith”属性或方法，通过添加babel-polyfill解决 12import babel-polyfill for IE9+ 通过Nginx配置路由直接访问二级路由会404，通过nginx把页面定向到inedx.html，让react-router接管页面路由 1234location / &#123; try_files $uri /index.html&#125; 开启Gzip页面访问速度过慢，于是开启Gzip对数据压缩传输 12345gzip on; # 开启Gzipgzip_comp_level 6; # 级别为1-9，9是最高的压缩比gzip_types *; # 压缩所有类型文件gzip_vary on; # 添加响应头","tags":[{"name":"React","slug":"React","permalink":"https://bergwhite.github.io/tags/React/"}]},{"title":"NodeJS项目迁移兼Ubuntu下NodeJS环境部署","date":"2017-08-05T05:39:14.000Z","path":"2017/08/05/NodeJS项目迁移兼Ubuntu下NodeJS环境部署/","text":"前言之前做的几个项目都托管在阿里云服务器，但是最近要到期了。想着到底要不要续期，毕竟100/月。后面看着阿里云有个活动，800/三年。果断买下。环境部署折腾了一天，其中也遇到几个坑。 目录1234567891011121314151617181920一、安装环境 1.1 安装NodeJS环境 1.2 安装版本控制软件Git 1.3 安装MongoDB数据库 1.4 安装Nginx二、导入数据三、安装项目四、部署项目 4.1 Nginx配置 4.2 启用HTTPS 4.3 使用PM2部署项目 4.4 开启阿里云外网访问五、踩坑记录 5.1 数据库导入失败 5.2 PM2部署失败 一、安装环境为了保证项目运行不出问题，在新服务器安装和原服务器一致的环境。项目迁移历时一天，两台服务器的系统都是Ubuntu 16.04 64位。 1.1 安装NodeJS环境自带的NodeJS版本是4.2.6，版本有点低，使用npm的n模块更新到最新版。 安装NPM 12sudo apt-get install npm 使用淘宝源 阿里云访问npm的速度非常慢，这里通过设置，让NPM从淘宝镜像更新模块 1234npm set registry https://registry.npm.taobao.org // 设置从淘宝镜像更新npm set disturl https://npm.taobao.org/distnpm cache clean // 清除缓存 更新NodeJS 1234npm install n // 更新NodeJS的模块n stable // 更新到最新稳定版node -v // v8.2.1 1.2 安装版本控制软件Git12sudo apt-get install git 1.3 安装MongoDB数据库1234sudo apt-get install mongodb // 安装MongoDBservice mongodb start // 启动服务mongod // 进入交互式控制台，能加入说明启动成功，ctrl+c退出 1.4 安装Nginx12sudo apt-get install nginx // 安装Nginx 二、导入数据把以前的数据库完整的迁移过来 从源服务器导出数据库 12mongodump -h localhost --port 27017 -d test -o database_dump 导入MongoDB数据库 12mongorestore -d test database_dump/test 三、安装项目项目是在Github开源，直接拉取就行。 12345git clone https://github.com/bergwhite/nchat.git // 克隆项目cd nchat // 进入目录npm install 安装模块npm run build 四、部署项目4.1 Nginx配置1234567891011121314151617181920212223242526272829303132333435363738vim /etc/nginx/nginx.conf // 编辑Nginx的配置http &#123; server &#123; listen 80; server_name hostName; rewrite ^(.*) https://$server_name$1 permanent; &#125; server &#123; listen 443 ssl; server_name hostName; ssl on; # SSL证书会插入到这里 # 完整根目录 location / &#123; root /*/*/*; index index.html; &#125; # 反向代理V2EX API到本地，解决跨域问题 location /api/ &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass https://www.v2ex.com/api/; &#125; &#125;... 4.2 启用HTTPS123456789sudo apt-get update // 更新软件源sudo apt-get install software-properties-common // 安装sudo add-apt-repository ppa:certbot/certbot // 添加仓库sudo apt-get update // 更新软件源sudo apt-get install python-certbot-nginx // 安装sudo certbot --nginx // 生成证书（自动添加到Nginx）sudo certbot --nginx certonly // 生成证书（手动添加到Nginx） 4.3 使用PM2部署项目12sudo apt-get install pm2 // 安装pm2 4.4 开启阿里云外网访问在安全组里添加需要放行的NodeJS项目端口即可。 五、踩坑记录5.1 数据库导入失败 导入数据库的时候，有一个Collection没有导入成功 12Assertion failure amt == (size_t)( size - 4 ) src/mongo/tools/tool.cpp 330 解决方案 12把报错的Collection单独导出，然后重新导入到新服务器的数据库 5.2 PM2部署失败 运行下面的代码会失败 12pm2 start -i 0 --name test ./bin/www 解决方案 使用fork模式启动 12pm2 start --name nchat3 ./bin/www 参考连接 让NPM从淘宝镜像更新模块 MongoDB备份和恢复 Ubuntu下的Nginx配置HTTPS","tags":[{"name":"NodeJS","slug":"NodeJS","permalink":"https://bergwhite.github.io/tags/NodeJS/"}]},{"title":"全栈式的开发多人在线聊天室","date":"2017-07-24T21:47:12.000Z","path":"2017/07/25/全栈式的开发多人在线聊天室/","text":"技术栈 觉得好的欢迎点个star ^_^。 前端：Express &amp; EJS &amp; ES6 &amp; Less &amp; Gulp 后端：Express &amp; SocketIO &amp; MongoDB &amp; REST API 部署：Linux &amp; PM2 演示 全栈式的开发多人在线聊天室 项目只适配了移动端，请使用浏览器的手机视图查看。 项目源码：https://github.com/bergwhite/nchat 在线演示：http://47.93.252.247:8086/ 目录 123456789101112131415├─bin│ www // 后端 服务器│ database // 后端 数据库│ socket // 后端 socket| router // 后端 路由├─sessions // 后端 session├─public│ src // 前端 开发目录│ dist // 前端 线上目录├─routes // 前端 路由├─view // 前端 页面├─app.js // 前端 服务器├─gulpfile.js // 前端 Gulp├─package.json 安装 项目基于MIT协议开源 启动项目以前，请确保已经安装mongodb，并在package.json中修改MongoDB的安装路径（–dbpath） Windows安装教程 | Linux安装教程 1234567git clone https://github.com/bergwhite/nodejs-chat // 克隆项目cd nodejs-chat // 进入目录npm install // 安装依赖npm run build // 构建 线上代码npm run mongod // 开启 数据库npm run start // 开启 聊天室 功能 聊天 √ 群聊 × 私聊 √ 表情 × 斗图 × 更多表情 √ 聊天机器人（图灵） 用户 √ 在线清单 √ 随机头像 √ 上线通知 √ 离线通知 √ 消息推送 × 上传头像 √ 在线统计 房间 √ 房间列表 √ 添加房间 × 搜索房间 优化 基础 √ 代码压缩 展示 √ 以前未设置头像的，显示默认头像 √ 加载速度优化 × 界面换肤 开发 √ 组件化开发 √ 模块化开发 √ REST API √ 使用PM2部署 √ 前后端分离 × 代码规范 × 测试用例 安全 √ 密码使用MD5+SALT保存 √ 聊天内容过滤&lt; &gt;等特殊标签 认证 √ Session 部署 Linux &amp; PM2 踩坑 图灵机器人不支持跨域，通过代理中间件把请求代理到本地。 1234567var proxy = require(&apos;http-proxy-middleware&apos;);app.use(&apos;/api/robot&apos;, proxy(&#123; target: &apos;http://www.tuling123.com&apos;, changeOrigin: true&#125;)); Gulp使用通配符对多个文件处理，会压缩到一个文件中。以下是分别进行压缩的方式。 12345678910111213141516171819202122232425262728293031const gulp = require(&apos;gulp&apos;), minifyJS = require(&apos;gulp-uglifyjs&apos;), babel = require(&apos;gulp-babel&apos;), rename = require(&apos;gulp-rename&apos;);const compileDir = &#123; css: &#123; src: &apos;public/src/css/index.less&apos;, dest: &apos;public/dist/css&apos; &#125;, js: &#123; src: &apos;public/src/js/&apos;, dest: &apos;public/dist/js&apos; &#125;&#125;;gulp.task(&apos;compile-js&apos;, () =&gt; &#123; const JSTaskList = [&apos;index&apos;, &apos;login&apos;, &apos;mobile&apos;, &apos;room&apos;, &apos;roomAdd&apos;, &apos;userInfoMod&apos;, &apos;roomMember&apos;] return JSTaskList.map((e) =&gt; &#123; gulp.src(`$&#123;compileDir.js.src&#125;$&#123;e&#125;.js`) .pipe(babel(&#123; presets: [&apos;es2015&apos;] &#125;)) .pipe(minifyJS()) .pipe(rename((path) =&gt; &#123; path.basename += &apos;.min&apos; &#125;)) .pipe(gulp.dest(compileDir.js.dest)) &#125;)&#125;); gulp-uglifyjs - No files given; aborting minification 12之前删除了一个JS文件，但是没有删除JSTaskList中的对应值。编译时会报上面的错误。删除对应的值就编译成功了。","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"如何通过路由器查看宽带的密码（多图预警）","date":"2017-07-21T11:10:23.000Z","path":"2017/07/21/如何通过路由器查看宽带的密码（多图预警）/","text":"这篇文章可能是我目前写的最水的一篇。不信？看看不就得了。 为什么要这样做？ 12在某些情况下，你需要重新配置路由器。但是你的宽带密码不记得，路由器恢复出厂设置则必须去重置宽带密码。很是麻烦。在这种情况下，你可以使用以下方法，找到密码（仅限TP-LINK部分系列）。 那么开始了 1/8 首先你在地址栏输入了以下地址 http://192.168.1.1/ 2/8 紧接着输入了管理账号密码 默认账号密码一般为admin/admin 默认账号密码一般写在路由器配备的说明书里 或者去百度一下是否有默认密码 如果你自己设置了账号密码就当我没说 3/8 通过步骤不多的操作，你看到了保存的账号和密码 网络参数 -&gt; WAN口设置 4/8 可是密码是隐藏状态，而且不允许右键，然而这并没有难到你 机智的你很巧妙的使用了F12快捷键绕过了他的限制 并点击了元素选择器 5/8 然后点击了密码输入框 6/8 紧接着你看到了熟悉的input控件，满意的笑了 7/8 顺手就是一个修改，把输入框从密码类型改为了文本类型 8/8 密码瞬间唾手可得 然而，故事就这样结束了？并没有 1/5 首先你好奇的打开了博主的聊天室项目，在看了一番介绍之后，决定试试效果怎样 https://github.com/bergwhite/nodejs-chat 2/5 于是你打开了博主的项目地址，发现他是不支持PC端的 http://47.93.252.247:8086/ 3/5 机智的你按下了F12快捷键，点击手机视图模式进入移动端，并点击了屏幕上的首页两个字 4/5 紧接着你进入了登陆页面，并输入了测试账号和密码，决定好好玩一番 账号：test 密码：test 5/5 进入之后，映入你眼帘的各种功能选项，于是你开始了你的探索之旅 写在最后 很感谢你能阅读到这里。很久没有更新过文章了，决定用这个新奇的小发现来水一水。同时也为下周一正式上线全栈式开发的移动端聊天室项目做热身。 前端的大牛和小白们，别喷我。如果非要喷，请轻点。 最近学习前端知识学的有点多，写个娱乐文放松放松。如果你们也能感到些许乐趣，实属我幸啊。","tags":[{"name":"路由器","slug":"路由器","permalink":"https://bergwhite.github.io/tags/路由器/"},{"name":"宽带密码","slug":"宽带密码","permalink":"https://bergwhite.github.io/tags/宽带密码/"}]},{"title":"用NodeJS打造多人在线聊天室（NodeJS & SocketIO & Express & EJS & MongoDB & Gulp）","date":"2017-05-31T05:10:43.000Z","path":"2017/05/31/用NodeJS打造多人在线聊天室（NodeJS & SocketIO & Express & EJS & MongoDB & Gulp）/","text":"项目背景 这个项目主要是为了玩玩NodeJS，项目的方向大概是做出类似QQ的在线聊天系统。想要在线体验可以点击在线演示。 项目使用PM2进行部署和管理，功能在不断的迭代开发中。如果你觉得这个项目比较有趣，或者能对你有所帮助，欢迎给个Star。 项目地址：https://github.com/bergwhite/nodejs-chat PS: 最近找工作，北京的欢迎联系。另外之前做过一个基于Vue全家桶二次开发的V2EX社区 https://github.com/bergwhite/v2ex-vue。 项目目录 123456789101112131415161718192021├─bin│ www // 启动express├─database│ index.js // MongoDB├─public // 静态文件│ css│ index.css // 首页CSS│ js│ index.js // 与socket服务进行通讯（关键文件）| socket-server.js // socket服务（关键文件）│ img├─routers│ index.js // 页面路由├─view│ error.ejs // 错误页│ index.ejs // 首页│ userCenter.ejs // 用户中心（规划中）│ userList.ejs // 用户列表（规划中）├─app.js // express├─package.json // npm包 路由 目前只有/目录和/room/:id正式使用了，其他路由的页面还在迭代开发中。 123456789/ // 首页/user // 用户列表/user/:id // 用户中心/user/:id/register // 注册（JSON）/user/:id/login // 登陆（JSON）/user/:id/logout // 注销（JSON）/user/:id/info // 用户资料（JSON）/room/:id // 指定聊天室 开始安装 使用之前，请在package.json中修改MongoDB的安装路径（–dbpath）。 1234567git clone https://github.com/bergwhite/nodejs-chat // 克隆项目到本地cd nodejs-chat // 进入项目目录npm install // 安装依赖npm run build // 构建线上代码npm run mongod // 启动MongoDB服务npm run start // 启动聊天室服务并启动网站 项目演示 目前项目存在一个已知的bug，表情包无法在div模拟的输入框中插入（修复中）。 匿名聊天 用户聊天 成员&amp;房间 离线通知 更多房间 房间独立 已上线功能 跨浏览器，跨地域聊天（SocketIO自带技能） 首次进入会显示欢迎信息 发送空消息会进行提示 直接发送消息默认昵称为“神秘人” 发送消息后会清空当前输入框内容，然后焦点回到消息输入框 添加用户名后会成为新用户，然后告知全房间人有新用户加入 可以创建不同的房间，不同的房间的聊天是相互独立的 显示当前房间的在线用户（设置了用户名的） 显示目前所有打开的房间 用户（设置了用户名的）离线会通知所有房间内的成员 压缩线上代码，加快访问速度 … 待上线功能 用户名 统计匿名用户 支持一键随机获取用户名 头像 访客使用默认头像 新用户（设置了用户名的）随机获得一个头像 新用户换头像可以从默认的一组头像中选择 是否支持上传头像还在考虑中（安全性问题） 聊天 支持多组丰富的表情包 是否支持上传图片还在考虑中（安全性问题） 数据库 对接MongoDB，新用户（设置了用户名的）设置密码后，将从临时用户转变为正式用户 项目缺陷 界面丑（等功能完善了再考虑） 表情包无法在div模拟的输入框中插入（修复中） …","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"用 Vue 全家桶二次开发 V2EX 社区","date":"2017-05-16T03:23:35.000Z","path":"2017/05/16/用 Vue 全家桶二次开发 V2EX 社区/","text":"一、开发背景为了全面的熟悉Vue+Vue-router+Vuex+axios技术栈，结合V2EX的开放API开发了这个简洁版的V2EX。 在线预览 （为了实现跨域，直接npm run dev部署的，首次加载略慢） API来自官方以及djyde的整理。 项目地址：v2ex-vue 二、项目演示分类页 文章页 &amp; 用户页 懒加载 路由 首页默认显示最新的帖子 首页 / 全部 /topic 分类 /topic/:name 文章 /article/:id 用户 /user/:name 三、项目优势 界面设计简洁 沉浸式的阅读体验 可以按分类/文章/用户浏览 在文章页显示用户评论 图片使用懒加载模式 总之，实现了你看帖所需要的一切 项目基于Vue全家桶 适配移动端 有完善的文档注释 有疑问欢迎提交issue 感兴趣的欢迎给颗star ^_^ … 四、项目缺陷 不支持翻页（没有找到翻页的API） 在线演示首次加载较慢（为了能跨域显示最新内容，直接用npm run dev部署的） 打算使用nginx部署，但是在代理的时候遇到了问题（https部署成功，反向代理失败） 配置文件在下面，希望大家帮忙看看问题在哪 … 1234567891011121314server &#123; listen 80; listen 443; server_name localhost; ssl on; ssl_certificate /etc/nginx/ssl/nginx.crt; ssl_certificate_key /etc/nginx/ssl/nginx.key; location /api/ &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass https://www.v2ex.com/api/; &#125;&#125; 五、项目安装项目兼容IE9+，使用项目前，请确保安装好了NodeJS。 12345git clone https://github.com/bergwhite/v2ex-vue.git // 克隆项目cd v2ex-vue // 进入项目目录npm install // 安装依赖npm run dev // 运行项目 六、解决方案6.1 跨域方案本地开发中，通过配置代理表实现跨域 123456789101112config/index.js-------------------proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;https://www.v2ex.com&apos;, changeOrigin: true, pathRewrite: &#123; &apos;^/api&apos;: &apos;/api&apos; &#125; &#125;&#125; 6.2 Vuex支持IE直接引入Vuex无法在IE中显示，引入babel-polyfill来兼容IE 123456npm install babel-polyfill --save-dev // 安装babel-polyfillsrc/main.js---------------import &apos;babel-polyfill&apos; // 在vue主文件中导入 PS：正在找工作，北京有坑的欢迎联系","tags":[{"name":"Vue","slug":"Vue","permalink":"https://bergwhite.github.io/tags/Vue/"}]},{"title":"《JavaScript面向对象编程指南（第2版）》读书笔记（二）","date":"2017-05-04T14:23:12.000Z","path":"2017/05/04/《JavaScript面向对象编程指南（第2版）》读书笔记（二）/","text":"《JavaScript面向对象编程指南（第2版）》读书笔记（一） 《JavaScript面向对象编程指南（第2版）》读书笔记（二） 目录12345678910111213141516171819202122一、基本类型 1.1 字符串 1.2 对象 1.3 原型 1.4 常用数学方法二、DOM操作 2.1 节点编号、名称以及值 2.2 父节点、子节点和相邻节点 2.3 添加和删除节点 2.4 属性相关 2.5 DOM合集 2.6 DOM遍历三、其他 3.1 事件 3.2 浏览器检测 3.3 三种弹窗方式 3.4 根据浏览器历史控制前进后退 3.5 重载页面的六种方式 3.6 修改当前页面URL但是不刷新页面 3.7 URI编码 3.8 窗口相关 一、基本类型1.1 字符串判断是否包含某个字符串 indexOf方法中，找到相关字符串会返回第一次出现的下标。没有找到就会返回-1，利用这个特性可以判断字符串是否存在。 12console.log(&apos;Fine&apos;.indexOf(&apos;in&apos;) !== -1) // true 把字符串按照一定规则分离成数组 下面是以空格为分割标志。 12console.log(&apos;I seek you&apos;.split(&apos; &apos;)) // [&quot;I&quot;, &quot;seek&quot;, &quot;you&quot;] 复制指定位置的字符串 传入的两个参数分别是开始的位置和结束的标记。看清楚，第二个参数本身的小标所表示的内容不会被复制，第二个参数是用来标记，这里是结束位置。 123console.log(&apos;I seek you&apos;.slice(2,6)) // seekconsole.log(&apos;I seek you&apos;.substring(2,6)) // seek 拼接字符串 12console.log(&apos;I seek you&apos;.concat(&apos; too.&apos;)) // I seek you too. 查看字符串中的字符 123console.log(&apos;I seek you&apos;[0]) // Iconsole.log(&apos;I seek you&apos;.charAt(0)) // I 1.2 对象判断属性是自己的还是继承来的 使用in不能判断属性是自己的还是继承来的，使用hasOwnProperty可以。 1234567891011var xiaoming = &#123; name: &apos;xiaoming&apos;&#125;使用in不能判断属性是自己的还是继承来的---------------------------------&apos;name&apos; in xiaoming // true&apos;toString&apos; in xiaoming // true---------------------------------xiaoming.hasOwnProperty(&apos;name&apos;) // truexiaoming.hasOwnProperty(&apos;toString&apos;) // false 判断对象是否可枚举 12xiaoming.propertyIsEnumerable() // false 判断对象是另一个对象的原型 123456789var People = function (name) &#123; this.name = name&#125;var xiaoming = new People(&apos;xiaoming&apos;)Human.prototype = monkeymonkey.isPrototypeOf(man) 1.3 原型 __proto__是实例对象的属性 prototype是构造函数的属性 constructor指向构造函数 IE中不存在__proto__，推荐使用ES5的Object.getPropertyOf()访问。 1234typeof [].__proto__ // &quot;object&quot;Object.getPrototypeOf([]) // [constructor: function, toString: function, toLocaleString: function, join: function, pop: function…][].constructor.prototype 原型继承 1234567var People = function (name,age) &#123; this.name = name this.age = age&#125;xiaoming = People.prototypexiaoming.constructor = xiaoming 1.4 常用数学方法123456789101112131415Math.PI // 3.141592653589793Math.SQRT2 // 1.4142135623730951Math.sqrt(2) // 1.4142135623730951Math.E // 2.718281828459045Math.pow(2,3) // 8Math.random() * (10-2)+2 // 7.564475903879611 | 2-8之间的平均数Math.LN2 // 0.6931471805599453Math.floor(2.6) // 2 | 指定值的最小整数Math.ceil(2.6) // 3 | 指定值最大整数Math.round(2.6) // 3 | 去最靠近指定值的整数Math.max() // 3Math.min() // 2Math.sin(90) // 0.8939966636005579Math.cos(90) // -0.4480736161291702 二、DOM操作2.1 节点编号、名称以及值nodeType有12种，具体请见MDN 123456789&lt;div class=&quot;you&quot;&gt;HELLO YOU&lt;/div&gt;var you = document.getElementsByClassName(&apos;you&apos;)[0]you.nodeType // 1you.nodeName // BIVyou.nodeValue // nullyou.textContent // HELLO YOUyou.innerText // &quot;HELLO YOU&quot; 2.2 父节点、子节点和相邻节点检查是否具有某个子节点 12document.documentElement.hasChildNodes(&apos;body&apos;) // true 查看所有子节点 12document.documentElement.childNodes // [head, text, body] 查看第一个子节点 12document.documentElement.firstChild // &lt;head&gt;...&lt;/head&gt; 访问父节点 12document.documentElement.childNodes[0].parentNode 访问相邻节点 123document.documentElement.children[0].previousSibling // nulldocument.documentElement.children[0].nextSibling // #text 2.3 添加和删除节点1234&lt;div class=&quot;you&quot;&gt;HELLO YOU&lt;/div&gt;var you = document.getElementsByClassName(&apos;you&apos;)[0] 新建节点 1234var pTag = document.createElement(&apos;p&apos;)var pVal = document.createTextNode(&apos;HELLO YOU&apos;)pTag.appendChild(pVal) // &lt;p&gt;HELLO YOU&lt;/p&gt; 添加节点 123document.body.insertBefore(pTag,you)document.body.replaceChild(you,pTag) 删除节点 12document.body.removeChild(you) 克隆节点 true为深拷贝，会拷贝节点的内容。flase只拷贝空标签。 12345var newNodeFalse = document.body.cloneNode(true)var newNodeFalse = document.body.cloneNode(false)console.log(newNodeFalse) // &lt;body&gt;...&lt;/body&gt;console.log(newNodeFalse) // &lt;body&gt;&lt;/body&gt; 2.4 属性相关1234&lt;div class=&quot;you&quot;&gt;HELLO YOU&lt;/div&gt;var you = document.getElementsByClassName(&apos;you&apos;)[0] 检查是否具有某个属性 12you.hasAttributes(&apos;class&apos;) // true 获取具体属性 1234you.getAttribute(&apos;class&apos;) // &quot;you&quot;you.attributes[0].nodeValue // &quot;you&quot;you.attributes[&apos;class&apos;].nodeValue // &quot;you&quot; 选择器 querySelector使用的是CSS选择器，返回单个节点。返回所有匹配的结果用querySelectorAll。 123document.querySelector(&apos;.you&apos;)document.querySelectorAll(&apos;.you&apos;) // [div.you] 批量添加样式 12you.style.cssText = &quot;color:red;font-size:200px;&quot; 2.5 DOM合集12345678910document.imagesdocument.appletsdocument.linksdocument.anchorsdocument.formsdocument.cookiedocument.titledocument.referrerdocument.domain 2.6 DOM遍历1234567891011function walkDOM(n)&#123; do &#123; console.log(n) if(n.hasChildNodes())&#123; walkDOM(n.firstChild) &#125; &#125; while (n=n.nextSibling)&#125;walkDOM(document.body) 三、其他3.1 事件阻止冒泡 123event.stopPropagation()window.event.cancelBubble = true //IE 阻止默认事件 123event.preventDefault()return false // IE 拖动事件 MDN在线示例 触屏事件 这里有一个用canva实现的画图页面，触屏画图，实现过程可以直接看源码。。另外触屏事件的分析，请见伯乐在线。 123456touchstarttouchmovetouchendtouchleavetouchcancel 3.2 浏览器检测用户代理可以被模拟，所以根据浏览器的不同特征来检测当前浏览器类型更加可靠。 1234567if(window.addEventlistener) &#123; // code...&#125;else if()&#123; // code...&#125; 3.3 三种弹窗方式三种弹窗分别是提示框（alert），确认框（confirm）和交互框（prompt）。可以把确认和交互赋值给变量，变量会存储相应结果。 123456alert(&apos;Welcome To JS!&apos;)var isLike = confirm(&apos;Do you like JS?&apos;)var whyLike = prompt(&apos;Why do you like it.&apos;)console.log(isLike) // trueconsole.log(whyLike) // Maybe... 3.4 根据浏览器历史控制前进后退根据缓存的浏览器历史，可以控制前进、后退和跳转到指定历史记录。 1234window.history.forward() // 前进window.history.back() // 后退window.history.go(1) // 跳转 3.5 重载页面的六种方式1234567location.reload()location.assign(&apos;/&apos;)location.replace(&apos;/&apos;)window.location.href = &apos;/&apos;location = locationwindow.location.reload() 3.6 修改当前页面URL但是不刷新页面12history.pushState(&#123;a:1&#125;,&apos;&apos;,&apos;hello&apos;) 3.7 URI编码123456789101112function decodeURI(url,params)&#123; var url = url || &apos;http://www.cnblogs.com/bergwhite/&apos; var params = params || &#123;name: &apos;berg&apos;, age: 22&#125; var query = [] for (param in params) &#123; query.push(param+&apos;=&apos;+params[param]) &#125; return url+=query.join(&apos;&amp;&apos;)&#125;decodeURI() // &quot;http://www.cnblogs.com/bergwhite/name=berg&amp;age=22&quot;decodeURI(&apos;http://www.you.com/&apos;,&#123;a:1,b:2&#125;) // &quot;http://www.you.com/a=1&amp;b=2&quot; 3.8 窗口相关新窗口打开内容 12window.open(&apos;http://www.baidu.com&apos;,&apos;zzzzzzzzzzzz&apos;,&apos;width=800px,height=300px,resizable=yes&apos;) 判断是否是高分辨率屏幕 12window.devicePixelRatio // 1 感谢您的阅读。","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"《JavaScript面向对象编程指南（第2版）》读书笔记（一）","date":"2017-04-22T14:11:34.000Z","path":"2017/04/22/《JavaScript面向对象编程指南（第2版）》读书笔记（一）/","text":"《JavaScript面向对象编程指南（第2版）》读书笔记（一） 《JavaScript面向对象编程指南（第2版）》读书笔记（二） 目录1234567891011121314151617181920212223242526一、对象 1.1 获取属性值的方式 1.2 获取动态生成的属性的值二、数组 2.1 检测是否为数组 2.2 增加数组长度导致未赋值的位置为undefined 2.3 用闭包实现简易迭代器三、作用域 3.1 函数作用域（局部变量） 3.2 不存在块级作用域 3.3 变量泄露 3.4 变量提升 3.5 临时作用域四、闭包 4.1 操作闭包中的值五、事件监听六、类型检测七、类型转换八、URL编码 8.1 编码 8.2 解码九、JSON格式 9.1 转为JSON格式 9.2 转为对象十、兼容性问题 一、对象1.1 获取属性值的方式123456water = &#123; down: false&#125;console.log(water.down) // falseconsole.log(water[&apos;down&apos;]) // false 1.2 获取动态生成的属性的值123var type = &apos;down&apos;console.log(water[type]) // false 二、数组2.1 检测是否为数组123456typeof([1,2]) // objectArray.isArray([1,2]) // trueObject.prototype.toString.call([1,2]) // [object Array]Array.isArray(Array.prototype) // trueObject.prototype.toString.call(Array.prototype) // [object Array] 2.2 增加数组长度导致未赋值的位置为undefined减少数组长度则会裁去多余的值。 123456var x = [1,2];x.length = 7;console.log(x); // [1, 2, undefined × 5]x.length = 1;console.log(x); // [1] 2.3 用闭包实现简易迭代器123456789101112var next = setup([3,3,9]);function setup(x)&#123; var i = 0; return function()&#123; console.log(x[i++]); &#125;&#125;next(); // 3next(); // 3next(); // 9next(); // undefined 三、作用域3.1 函数作用域（局部变量）不能在函数体外直接访问函数内变量。 12345function water() &#123; var direction = &apos;down&apos;&#125;console.log(direction) // Uncaught ReferenceError: direction is not defined 3.2 不存在块级作用域for、if等代码块中的变量不是局部变量。 12345if(water)&#123; var down = true&#125;console.log(down) // true 3.3 变量泄露函数体内的变量未声明，会在函数第一次执行的时候泄露成全局变量。 123456function water() &#123; direction = &apos;down&apos;&#125;water() // 执行函数console.log(direction) // down 3.4 变量提升已声明的变量名会提升至顶部，值不会提升。 123456789var down = truefunction water() &#123; // 变量提升覆盖了外部down，由于值没有提升，所以为undefined console.log(down) // undefined var down = false // false console.log(down)&#125;water() 3.5 临时作用域1234call和apply借用另一个对象的方法，提高代码复用第一个参数为this的指向，第二个参数为传入的参数，apply传入数组构造函数不使用new this的值会指向window 四、闭包4.1 操作闭包中的值123456789101112131415161718var nature = (function() &#123; var water = &#123;&#125; water.down = false water.get = function(type) &#123; return water[type] &#125; water.set = function(type,val) &#123; water[type] = val return typeof(val) === &apos;boolean&apos; ? true : false &#125; return &#123; getWater: water.get, setWater: water.set &#125;&#125;)()console.log(nature.getWater(&apos;down&apos;)) // falseconsole.log(nature.setWater(&apos;down&apos;,true)) // true 五、事件监听12345678910111213141516171819202122232425262728293031var event = &#123; add: function ( dom,type,func ) &#123; if(window.addEventListener)&#123; dom.addEventListener( type,func,false ) &#125; // 兼容IE9以下 else if(document.attachEvent) &#123; dom.attachEvent(&apos;on&apos; + type,func) &#125; else &#123; dom[&apos;on&apos; + type] = func &#125; &#125;, del: function ( dom,type,func ) &#123; if(window.addEventListener)&#123; dom.removeEventListener( type,func,false ) &#125; else if(document.attachEvent) &#123; dom.detachEvent(&apos;on&apos; + type,func) &#125; else &#123; dom[&apos;on&apos; + type] = null &#125; &#125;&#125;var f = function()&#123; console.log(&apos;event received&apos;)&#125;event.add(document.body,&apos;click&apos;,f)event.del(document.body,&apos;click&apos;,f) 六、类型检测6.1 常用类型1234typeof(1) // &quot;number&quot;number/boolean/string/undefined/object/function 6.2 继承检测1234567function Water (name,status) &#123; this.name = name this.status = status&#125;var seaWater = new Water(&apos;sea&apos;,&apos;warm&apos;)seaWater instanceof Water // true 6.3 NaN和isFinite检测NaN不等于NaN，检测需要使用isNaN函数。 12NaN === NaN // falseisNaN(NaN) // true 七、类型转换7.1 转为整形parseInt和parseFloat碰到第一个异常字符就会终止。 123console.log(parseInt(66.5t)) // 66.5console.log(parseInt(t66.5t)) // NaN 7.2 null和undefined数值超出范围则显示Infinity。 123console.log(1*undefined) // NaNconsole.log(1*null) // 0 八、URL编码8.1 编码1234var src = &quot;http://www.cnblogs.com/bergwhite/p/6657943.html&quot;var srcURI = encodeURI(src) // &quot;http://www.cnblogs.com/bergwhite/p/6657943.html&quot;var srcURICom = encodeURIComponent(src) // &quot;http%3A%2F%2Fwww.cnblogs.com%2Fbergwhite%2Fp%2F6657943.html&quot; 8.2 解码123decodeURI(srcURI) // &quot;http://www.cnblogs.com/bergwhite/p/6657943.html&quot;decodeURIComponent(srcURI) // &quot;http://www.cnblogs.com/bergwhite/p/6657943.html&quot; 九、JSON格式9.1 转为JSON格式12345var water = &#123; down: false&#125;var waterJSON = JSON.stringify(water) // &quot;&#123;&quot;down&quot;:false&#125;&quot; 9.2 转为对象12JSON.parse(waterJSON) // Object &#123;down: false&#125; 十、兼容性问题123parseInt(09) // ES5中默认不转换八进制，ES3会默认作为八进制parseInt(09,10) // 当值为日期的时候，作为十进制处理 感谢大家的阅读。","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"前端总结·基础篇·JS（四）异步请求及跨域方案","date":"2017-04-01T16:08:31.000Z","path":"2017/04/02/前端总结·基础篇·JS（四）异步请求及跨域方案/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录123456789一、异步请求 1.1 XHR（XMLHttpRequest） 1.2 Promise（ES6） 1.3 Fetch二、跨域方案 2.1 JSONP（JavaScript Object Notation with Padding） 2.2 CORS（Cross-origin resource sharing） 一、异步请求此文只进行简单的介绍，完整的用例请见我的Github。Github上的用例，对这三种方法的POST和GET请求都进行了封装。 Github演示不支持POST请求，所以会有部分报错。完整测试可以放在本机的localhost下。 12345678a.json-------------&#123;&quot;user&quot;:&quot;张三&quot;,&quot;folling&quot;:30,&quot;foller&quot;: 20&#125; 1.1 XHR（XMLHttpRequest）三行代码实现异步请求 下面是发送XHR请求之后，返回的成功信息。 123456&lt;script type=&quot;text/javascript&quot;&gt; var xmlhttp = new XMLHttpRequest() // 创建异步请求 xmlhttp.open(&apos;GET&apos;,&apos;a.json&apos;) // 使用GET方法获取hello.txt文件 xmlhttp.send() // 发送异步请求&lt;/script&gt; 读取异步请求返回的数据 返回的数据存储在xmlhttp.responseText。 怎么返回了这么多内容？请接着往下看。 1234567891011&lt;script type=&quot;text/javascript&quot;&gt; var xmlhttp = new XMLHttpRequest() // 异步请求状态发生改变时会执行这个函数 xmlhttp.onreadystatechange = function () &#123; // 显示返回的内容 console.log(xmlhttp.responseText) &#125; xmlhttp.open(&apos;GET&apos;,&apos;hello.txt&apos;) xmlhttp.send()&lt;/script&gt; 异步请求的状态 现在就好了，我们在使用xmlhttp.responseText之前判断了一下当前ajax的状态。确认完成了，我们才返回值。 123456789101112&lt;script type=&quot;text/javascript&quot;&gt; var xmlhttp = new XMLHttpRequest() xmlhttp.onreadystatechange = function () &#123; // status == 200 用来判断当前HTTP请求完成 if ( xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200 ) &#123; console.log(xmlhttp.responseText) &#125; &#125; xmlhttp.open(&apos;GET&apos;,&apos;hello.txt&apos;) xmlhttp.send()&lt;/script&gt; 异步请求一共有五个状态，用来标识异步请求的不同阶段。 0 UNSENT 代理被创建，但尚未调用 open() 方法 1 OPENED open() 方法已经被调用 2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得 3 LOADING 下载中； responseText 属性已经包含部分数据 4 DONE 下载操作已完成 上面返回的五条数据中，一条是XHR请求成功默认返回的。前两条对应的状态1和2，是没有返回内容的，所以为空。后面两条有内容的对应的是3和4。 因此，我们想要数据完全下载完成了再显示返回内容，只需要用if判断一下当前状态是否是4即可。 关于HTTP状态码代表的意义，可以看我之前写过的文章。 封装XHR方法 12345678910111213function ajax (method,url,callback) &#123; var xmlhttp = new XMLHttpRequest() // 创建异步请求 // 异步请求状态发生改变时会执行这个函数 xmlhttp.onreadystatechange = function () &#123; // status == 200 用来判断当前HTTP请求完成 if ( xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200 ) &#123; callback(JSON.parse(xmlhttp.responseText)) // 执行回调 &#125; &#125; xmlhttp.open(method,url) // 使用GET方法获取 xmlhttp.send() // 发送异步请求&#125; 调用XHR方法 12345678910ajax(&apos;GET&apos;,&apos;a.json&apos;,function (res) &#123; console.log(res) // 显示返回的对象 ajax(&apos;GET&apos;,&apos;b.json&apos;,function (res) &#123; console.log(res) ajax(&apos;GET&apos;,&apos;c.json&apos;,function (res) &#123; console.log(res) &#125;) &#125;)&#125;) 1.2 Promise（ES6）我们在用Ajax写异步的时候，很容易掉入回调地狱（callback），代码的可读性会大大的下降。Promise可以让代码变得更优雅。 封装基于Promise的XHR 12345678910111213141516function ajax ( method,url ) &#123; // 返回一个Promise对象 return new Promise(function (resolve) &#123; var xmlhttp = new XMLHttpRequest() // 创建异步请求 // 异步请求状态发生改变时会执行这个函数 xmlhttp.onreadystatechange = function () &#123; // status == 200 用来判断当前HTTP请求完成 if ( xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200 ) &#123; resolve(JSON.parse(xmlhttp.responseText)) // 标记已完成 &#125; &#125; xmlhttp.open(method,url) // 使用GET方法获取 xmlhttp.send() // 发送异步请求 &#125;)&#125; 调用基于Promise的XHR 12345var aj = ajax(&apos;GET&apos;,&apos;a.json&apos;)aj.then(function (res) &#123; console.log(res)&#125;) 1.3 fetch fetch是对Promise的一个封装，使用非常方便。 12345678fetch(&apos;a.json&apos;).then(function (res)&#123; return res // 返回Promise&#125;).then(function (res) &#123; return res.json() // 返回JSON对象&#125;).then(function (json) &#123; console.log(json) // 显示JSON内容&#125;) 二、跨域方案CORS方法更好一些，但是需要对服务器有自主权。JSONP则不需要对服务器有自主权，可以通过script、img等标签可以发送GET请求的特点，通过回调函数执行已有的JS函数。在函数内获取返回值。 CORS支持所有HTTP请求，JSONP只支持GET请求。 2.1 JSONP（JavaScript Object Notation with Padding）1234567891011121314151617用回调跨域------------------------&lt;script type=&quot;text/javascript&quot; src=&quot;http://localhost/async/cors.php?callback=go&quot;&gt;&lt;/script&gt;设置好回调函数------------------------function go (arr) &#123; console.log(arr) // 显示回调的值 | &#123;a:&quot;1&quot;&#125;&#125;script发送的GET请求时，返回的值是一个函数，遂执行回调函数------------------------&lt;?php $go=$_GET[&apos;callback&apos;]; // 获取callback的值echo $go.&apos;(&#123;a:&quot;1&quot;&#125;)&apos;; // 输出回调函数?&gt; 2.2 CORS（Cross-origin resource sharing）PHP配置CORS 1234&lt;?php header(&quot;Access-Control-Allow-Origin:*&quot;); // *号为允许所有域名，推荐修改成需要跨域的域名?&gt; 配置CORS前 配置CORS后 总结下一篇总结Vue。 参考 AJAX - MDN XMLHttpRequest - MDN XHR——XMLHttpRequest对象 - gaojun XMLHttpRequest 对象 - W3Scool 跨域资源共享 CORS 详解 - 阮一峰 JavaScript异步编程（1）- ECMAScript 6的Promise对象 - fetch使用的常见问题及解决办法 - wonyun 你不需要jQuery(三)：新AJAX方法fetch() - 唸随爱 深入浅出Fetch API 带你入解应用场景及适用问题 - Ludovico Fischer","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"前端总结·工具篇·管理（一）常用模块化方案","date":"2017-03-25T13:25:32.000Z","path":"2017/03/25/前端总结·工具篇·管理（一）常用模块化方案/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录12345678910111213一、模块化规范 1.1 AMD规范（Asynchronous Module Definition） 1.2 CMD规范（Common Module Definition） 1.3 CommonJS规范（NodeJS模块化方案） 1.4 ES6模块（需要使用babel转码）二、使用Webpack对模块进行打包 2.1 安装Webpack 2.2 导出的模块都导出了什么？ 2.3 打包JS模块 2.4 更轻松的打包方式 2.5 打包CSS模块 一、模块化规范1.1 AMD规范（Asynchronous Module Definition）AMD规范的实现有RequireJS，下面是一个完整的示例。 AMD规范完整定义 require.js用例 require.js官网 12345678910111213141516171819202122232425262728293031323334353637index.html---------------&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 引入require.js --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.bootcss.com/require.js/2.3.3/require.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;myName.js---------------// 定义模块define(&apos;myName&apos;,[],function () &#123; return &apos;My name is white.&apos;&#125;)yourName.js---------------// 定义模块define(&apos;yourName&apos;,[],function () &#123; return &apos;Your name is lily.&apos;&#125;)main.js---------------// 调用模块require([&apos;myName&apos;,&apos;yourName&apos;],function (myName,yourName) &#123; console.log(myName) console.log(yourName)&#125;) 1.2 CMD规范（Common Module Definition）AMD规范的实现有SeaJS，下面是一个示例。 1234567define(function(require, exports, module) &#123; var $ = require(&apos;jquery&apos;); // 导入模块 var Spinning = require(&apos;./spinning&apos;); exports.doSomething = ... module.exports = ... // 导出模块&#125;) 1.3 CommonJS规范（NodeJS模块化方案）CommonJS规范主要用在NodeJS，下面是一个示例。 CommonJS规范 1234require(&apos;./test&apos;); // 导入当前目录中的模块require(&apos;jquery&apos;); // 导入模块目录中的模块module.exports = &#123;&#125; // 导出模块 1.4 ES6模块（需要使用babel转码）ES6模块需要使用babel转码，下面是一个示例。 ES6模块文档 - 廖雪峰 1234import &apos;./test&apos;; // 导入当前目录中的模块import &apos;jquery&apos;; // 导入模块目录中的模块export function test() &#123;&#125; // 导出模块 二、使用Webpack对模块进行打包JS文件可以直接使用CommonJS语法或者ES6（需要使用babel转码）进行模块化。CSS，图片等其他资源需要配备相应的Loader进行模块化。 2.1 安装Webpack -D等同于–save-dev，-S等同于–save。前者保存在npm配置文件（package.json）的dependencies，后者保存在devDependencies。 123npm init -y // 生成npm配置文件npm install webpack -D // 安装Webpack 2.2 导出的模块都导出了什么？导出的内容可以是字符串，可以是对象，可以是函数。也可以是其他JS数据类型。但是每个文件只能导出一个模块。 123456789101112131415161718192021222324252627yourName.js---------------var str = &apos;Your name is lily.&apos;module.exports = str // 导出模块main.js---------------var yourName = require(&apos;./yourName&apos;) // 导入模块console.log(yourName) // 测试导出的模块下面我们来分别修改yourName.js中的module.exports的数据类型，然后输入node main.js指令进行测试。yourName.js（每个文件只能导出一个模块，请逐个进行测试）---------------module.exports = &apos;hello&apos; // 导出字符串 | &apos;hello&apos;module.exports = &#123;a:1,b:2&#125; // 导出对象 | &#123; a: 1, b: 2 &#125;module.exports = function () &#123; // 导出函数 | [Function] console.log(&apos;hello&apos;)&#125;main.js（对应的调用方法如下）---------------var yourName = require(&apos;./yourName&apos;)console.log(yourName) // &apos;hello&apos;console.log(yourName.a) // 1console.log(yourName()) // &apos;hello&apos; 2.3 打包JS模块在同一目录创建以下文件。all.js里面是没有内容的，用来放置打包后的模块。myName.js和yourName.js都会导出内容，main.js把这两个文件导入。通过webpack main.js all.js指令把main.js以及导入的模块，全部打包到all.js里面。 1234567891011121314151617181920212223242526272829303132index.html---------------&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 所有的JS都会打包到all.js --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;all.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;myName.js---------------var str = &apos;My name is white.&apos; // 定义变量module.exports = str // 输出模块yourName.js---------------var str = &apos;Your name is lily.&apos;module.exports = strmain.js---------------var myName = require(&apos;./myName&apos;) // 导入模块（当前目录要使用./）var yourName = require(&apos;./yourName&apos;)console.log(myName) // 测试导入的模块console.log(yourName) // webpack main.js all.js // 打包指令（左边的文件打包到右边） 2.4 更轻松的打包方式上面的方式，每次都得输入源文件，和打包后的文件，确实非常麻烦。你可以配置以下文件实现输入webpack指令即可打包文件。 123456789101112webpack.config---------------var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; path: __dirname, filename: &apos;all.js&apos; &#125;&#125; 2.5 打包CSS模块打包CSS模块需要配置Loader。 12345678910111213141516171819202122232425262728// 安装CSS Loadernpm install css-loader style-loader// 配置CSS Loadermodule: &#123; loaders: [ &#123;css: /\\.css$/, loader: &apos;style-loader!css-loader&apos;&#125; ]&#125;webpack.config.js（Webpack配置文件）---------------------var webpack = require(&apos;webpack&apos;)module.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; path: __dirname, filename: &apos;all.js&apos; &#125;, module: &#123; loaders: [ &#123;test: /\\.css$/, loader: &apos;style-loader!css-loader&apos;&#125; ] &#125;&#125; 总结文章主要参考以下网站 Webpack中文指南 博客更的有点慢了，还会继续更下去。博客算是半摘录半总结，引用了较多内容的基本都留了原文链接。如果介意的话欢迎私信我。虽然写的一系列文章，并非完全原创。但是这一段时间下来，感觉确实学到了很多。知识在逐步体系化，不会像以前那样零散。Fighting。 下一篇总结异步。","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数","date":"2017-03-17T15:04:17.000Z","path":"2017/03/17/前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录12345678910一、函数使用 1.1 函数声明和函数表达式 1.2 函数封装（自调用函数、闭包） 1.3 函数属性（arguments、callee） 1.4 构造函数二、函数技巧 2.1 改变函数作用域（call/apply/bind） 2.2 for循环中的setTimeout问题修复 一、函数使用字符串和数组都是用来存储数据。需要做一些特定的事情的时候，我们就会会用函数封装起来。 1.1 函数声明和函数表达式声明一个函数可以用函数声明或者函数表达式。 函数表达式必须先声明后调用 函数内的变量需要使用var声明，否则会污染全局变量 123456789101112131415function hello( name ) &#123; some code ... &#125; // 函数声明var hello = function ( name ) &#123; some code ... &#125; // 函数表达式// 变量提升 | 函数内部的变量未使用var声明，执行后会导致变量成为全局变量var age = 22function showAge()&#123; age = 23 console.log(age)&#125;showAge() // 23 | 执行函数console.log(age) // 23 | 测试全局变量age的值 1.2 函数封装（自调用函数、闭包）实际项目中会引入很多外部JS文件，为了避免彼此命名冲突。通常各自都会对内部函数进行封装。（现在更好的方案是使用模块化，模块化以后再总结） 自调用函数 使用自调用函数，把整个JS文件的代码都封装在内。 这样做的好处是不会污染全局变量，可以很好的减少命名冲突。 最后把对外访问的接口挂载在window上。 12345(function()&#123; // some code ... window.myApp = myApp() // 把对外访问的接口挂载在window上&#125;)() 闭包封装 如果你内部使用的是函数表达式，并且不用var声明，变量依旧会泄露到全局。 123456789101112131415161718192021222324// a.js(function()&#123; function myApp() &#123; // 定义showName方法 function showName(name) &#123; console.log(name) &#125; // 定义showAge方法 function showAge(age)&#123; console.log(age) &#125; // 返回一个对象 return &#123; showName: showName, showAge: showAge &#125; &#125; window.myApp = myApp()&#125;)() 功能扩展 引入上面的a.js文件，并且创建b.js来写程序主逻辑。 你也可以写在一个文件，写在两个文件是为了把接口和控制器分开，方便管理。 你可以修改上面提供的方法，或者新添加一条方法。 12345678910111213141516//b.js// 修改已有方法myApp.showName = function (name) &#123; console.log(&apos;Call me &apos;+name)&#125;// 定义新方法myApp.showCity = function (city) &#123; console.log(city)&#125;myApp.showName(&apos;berg&apos;) // 能够访问 | bergmyApp.showCity(&apos;NanChang&apos;) // 能够访问 | NanChangshowName(&apos;berg&apos;) // 不能访问 | Uncaught ReferenceError: showName is not defined 1.3 函数属性（arguments、callee）arguments是用来存放实参的，可以通过下标访问实参的值。callee指向当前执行的函数，可以在递归的时候用。具体递归场景以及代码，请见MDN。 callee不能实现尾递归 callee在ES5严格模式中禁止使用 caller指向调用当前函数的函数（已废弃） 12345678function show(name,age) &#123; console.log(name) // berg console.log(age) // 22 console.log(arguments) // [&quot;berg&quot;, 22] console.log(arguments.callee) // function show(name,age) &#123;&#125;&#125;show(&apos;berg&apos;,22) 1.4 构造函数ES6可以使用Class实现继承，以后在单独总结ES6的时候会提到。推荐一个非常好的ES6系列教程，深入浅出ES6 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 声明构造函数 Humanfunction Human() &#123; this.play = function()&#123; console.log(&apos;I\\&apos;m playing.&apos;) &#125;&#125;// 声明构造函数 Malefunction Male() &#123; this.sex = &apos;male&apos;&#125;// 声明构造函数 Femalefunction Female() &#123; this.sex = &apos;female&apos;&#125;// 让Male和Female继承HumanMale.prototype = new Human()Female.prototype = new Human()// 创建xiaoming对象并且测试继承结果var xiaoming = new Male()console.log(xiaoming.sex) // maleconsole.log(xiaoming.play()) // I&apos;m playing.// 创建xiaohong对象并且测试继承结果var xiaohong = new Female()console.log(xiaohong.sex) // femaleconsole.log(xiaohong.play()) // I&apos;m playing.``` ## 二、函数技巧### 2.1 改变函数作用域（call/apply/bind）当需要改变上下文的this的时候，可以使用call/apply/bind。（更详细的解释请见[ChokCoco](http://www.cnblogs.com/coco1s/p/4833199.html)，需要用call实现继承请见[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call)）* 三种方法的第一个参数都是this的上下文* apply第二个参数是数组，call和bind后面都是接单个参数* call和apply默认会自动执行，bind需要在后面加()来自动执行* bind是ES5语法，支持IE9+ /* 以下以数组合并为例子 使用不同的方法之前，请确保a和b为默认值*/ var a = [1,2,3] // 测试用的默认值var b = [4,5,6] // 测试用的默认值 a.push(b) // 直接使用push（不符合预期）console.log(a) // [1, 2, 3, Array[3]] // call方法（在这种情况下要逐个输入参数，不太方便） Array.prototype.push.call(a,4,5,6)console.log(a) // [1, 2, 3, 4, 5, 6] // apply方法（第二个参数直接传入数组，非常适用这种场景） Array.prototype.push.apply(a,b)console.log(a) // [1, 2, 3, 4, 5, 6] // bind方法 Array.prototype.push.bind(a,4,5,6)() // 注意看，这里需要加一个自动执行函数console.log(a) // [1, 2, 3, 4, 5, 6] 12345678### 2.2 for循环中的setTimeout问题修复setTimeout有自己的this。如果在外层放一个for循环，意味着会一次性执行完，而没有起到延时的作用。解决方案是使用闭包。此处主要参考[JavaScript 秘密花园](http://bonsaiden.github.io/JavaScript-Garden/zh/)* setTimeout是一个定时执行函数。接受两个参数，第一个是执行的函数，第二个是延迟执行的时间。通常用在登陆之后，提示几秒钟之后跳转到首页（现在基本不这样做了）。* setInterval和setTimeout基本一致。只是第二个时间参数，表示的是每多长事件执行一次。* 第二个参数的时间单位是毫秒（1000表示为1秒） // 使用闭包前 for(var x = 0; x&lt;10; x++) { setTimeout(run,1000) // 10} function run() { console.log(x)} // 使用闭包后 for(var x = 0; x&lt;10; x++) { setTimeout((function (x) { return function() { console.log(x) // 0 1 2 3 4 5 6 7 8 9 } })(x),1000)} ``` 总结全文主要参考以下网站 MDN JavaScript 秘密花园 ChokCoco 推荐的教程 JavaScript系列 @ 廖雪峰 JavaScript 标准参考教程（alpha） @ 阮一峰 深入理解JavaScript @ 汤姆大叔 深入浅出ES6 ECMAScript 6 入门 @ 阮一峰 张鑫旭博客 全文主要是参考MDN写出的总结。外加ChokCoco和JavaScript 秘密花园中的细致分析，以及自己平时的一些总结写成此文。 文中的错误还望能够指出，会及时做出修改（哪怕是错别字）。Vue的基本理念现在差不多搞清楚了，大概在下周，会对Vue做一个总结（其实官方文档是最好的总结 ^_^）。","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array）","date":"2017-03-14T14:03:24.000Z","path":"2017/03/14/前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array）/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录这是《前端总结·基础篇·JS》系列的第二篇，主要总结一下JS数组的使用、技巧以及常用方法。 12345678910111213141516一、数组使用 1.1 声明数组 1.2 访问数组 1.3 类型检测二、常用技巧 2.1 数组去重 2.2 数组深拷贝 2.3 字符串反序三、方法列表 3.1 存取 3.2 字符串 3.3 修改 3.4 ES5 3.5 ES2015(ES6) 3.6 ES2016 一、数组使用数组不是基本数据类型，但是非常常用，所以提前总结。 基本数据类型是String,Number,Boolean,null,undefined。 Boolean只有两个状态，true/false null一般是开发者定义 undefined是JS引擎抛出的异常，通常在发现调用未声明的变量时抛出 1.1 声明数组数组用中括号括起来，不同的值用逗号隔开。数组内的值有字符串需要用单引号或者双引号引起来。 123var arr = [] // 声明一个空数组var arr = [3,6,8,9] // 声明一个包含值3,6,8,9的数组var arr = new Array(3,6,8,9) // 创建一个数组对象 1.2 访问数组下标访问 数组的下标是从0开始的，最后一个值的下标是数组长度减去1。访问数组可以直接访问具体下标的一个值，也可以直接访问整个数组的值。 123456var arr = [1,2,3,4]console.log(arr) // 直接访问数组 | [1, 2, 3, 4]console.log(arr[0]) // 通过下标访问 | 1console.log(arr.length) // 访问数组的长度 | 4 遍历访问 如果需要逐个的访问数组中的值，你需要对数组进行遍历。可以用一般的for循环、for in或者ES6中的for of。 1234567891011121314151617var arr = [1,2,3,4]// forfor(var x = 0; x &lt; arr.length; x++)&#123; console.log(arr[x]) // 通过下标访问&#125;// for infor(x in arr)&#123; console.log(arr[x]) // 通过下标访问&#125;// for of (ES6)for(x of arr)&#123; console.log(x) // 不需要通过下标访问&#125; 1.3 类型检测检测一个对象有以下方法。更精确的检测数组请见请见jwalden 12345* typeof [] // object* [] instanceof Array // false* Array.isArray([]) // true | 通常用来检测数组 * Array.isArray(Array.prototype) // true | 这是一个例外情况 二、常用技巧2.1 数组合并可以用concat/push合并。concat返回合并后的新数组，push保存在原数组里。 感谢园友 @loveyatou 提醒。在push方法中把apply写成了call，导致结果不符合预期。现已修正。 2017/03/17 13:45 PS：call和apply都是用来改变函数作用域的，用法基本一致，唯独传递参数的方法不一致。call是逐个输入，逗号隔开。apply是全部放在一个数组内。 12345678910111213var a = [1,2,3]var b = [4,5,6]// concat 方法var c = a.concat(b)console.log(c) // [1, 2, 3, 4, 5, 6]// push 方法Array.prototype.push.apply(a,b)console.log(a) // [1, 2, 3, 4, 5, 6] 2.2 数组深拷贝我们可以根据concat/slice方法返回新数组的特性来进行深拷贝，也可以直接用循环语句暴力深拷贝。 把数组赋值给一个变量，只是复制了一个指向数组的指针（又叫引用） 当我们改变原数组的值，新数组的值也跟着改变 为了避免这样，你需要对数组进行深拷贝 123456789101112131415161718192021222324252627282930// 深拷贝前var arr = [1,2,3,4]var newArr = arr // 把原数组赋值给新数组arr.pop() // 删除原数组的一个值console.log(arr) // 测试原数组的值 [1, 2, 3]console.log(newArr) // 测试新数组的值 [1, 2, 3]// 深拷贝后var arr = [1,2,3,4]var newArrCopy = arr.concat() // 开始深拷贝，此处也可以使用arr.slice()arr.pop() // 删除原数组的一个值console.log(arr) // 测试原数组的值 [1, 2, 3]console.log(newArrCopy) // 测试新数组的值 [1, 2, 3, 4]// 暴力深拷贝var arr = [1,2,3,4]var newArr = [] // 为了使用数组的push方法，一定要定义数据类型为数组for (var x = 0; x &lt; arr.length; x++)&#123; newArr.push(arr[x]) // 用循环逐个把值保存在新数组内&#125;arr.pop() // 删除原数组的一个值console.log(arr) // 测试原数组的值 [1, 2, 3]console.log(newArr) // 测试新数组的值 [1, 2, 3, 4] 2.3 数组去重排序后去重，更多请见脚本之家 1234567var newArr = arr.sort() // 排好序再比较var newArrSaved = [newArr[0]] // 初始化为数组，用来存储最后的数据for(var i =2;i&lt;arr.length;i++)&#123; // 从第二个开始 if(newArr[i]!==newArr[i-1]) // 判断当前值和上一个值是否一致 newArrSaved.push(newArr[i]) // 不一致则存在newArrSaved&#125; 2.4 字符串反序首先将字符串序列化成数组，通过数组方法对数组反序，最后把数组转换成字符串。 12&apos;I See U.&apos;.split(&apos;&apos;).reverse().join(&apos;&apos;) // &quot;.U eeS I&quot; 三、方法列表ES5和ES6部分就当作参考手册吧，有时间再琢磨一下应用场景。 以下实例在此基础上进行 12arr = [1,2,3,4] 3.1 存取push在尾部添加，pop从尾部删除。 尾存取 12345push(element1, ..., elementN) * arr.push(8) // [1, 2, 3, 4, 5]pop() * arr.pop() // [1, 2, 3, 4] 首存取 unshift在首部添加，shift从首部删除。 123456unshift(element1, ..., elementN) * arr.unshift(5) // [5, 1, 2, 3, 4]shift * arr.shift() // [1, 2, 3, 4] 3.2 转换字符串 join默认以逗号分隔连接的字符串，传入参数可以进行自定义分割方式。 123456789toString() * arr.toString() // &quot;1,2,3,4&quot;toLocalString() * arr.toLocalString() // 和上面的效果一致，此方法仅在特殊语言中需要join(separator) * arr.join() // &quot;1,2,3,4&quot; * arr.join(&apos;&apos;) // &quot;1234&quot; * arr.join(&apos;-&apos;) // &quot;1-2-3-4&quot; 3.3 修改排序 reverse把数组颠倒，sort对数组排序。sort默认按照unicode排序，传入function(a,b)可以自定义排序。更多请见MDN（内有对象按属性值排序的方法） 12345reverse() * arr.reverse() // [4, 3, 2, 1]sort() * arr.sort() // [1, 2, 3, 4] 这个已经排好了序，所以不变 连接 concat连接数组，并返回一个新的数组。 123concat(value1[, value2[, ...[, valueN]]]) arr.concat(9) // [1, 2, 3, 4, 9] 切割 切割比上面的稍微复杂点 slice为提取元素，splice为删除指定范围元素并添加新元素。slice的第二个参数，是结束的位置标记，不会包括在返回值内。 slice的返回值是提取元素组成的新数组。splice的返回值是删除元素组成的新数组，原始元素被修改。 slice在IE&lt;9下使用时，会出现一些问题，需要使用腻子脚本。详见MDN 123456slice(begin,end) * arr.slice(1,3) // [2, 3]splice(start, deleteCount, item1, item2, ...) * arr.splice(1,3,5) // [2, 3, 4] 返回值 * console.log(arr) // [1, 5] 原始元素被修改 3.4 ES5需要精确检测数组请见jwalden 12345678910111213141516171819数组检查Array.isArray(obj) // 检查是否为数组，返回值为true/false，兼容IE9+ * Array.isArray([1,2,3]) // true * Array.isArray(&apos;123&apos;) // false * Array.isArray(Array.prototype) // truearr.every(callback[, thisArg]) * function isNotZero(element, index, array)&#123;return element!==0&#125; * arr.every(isNotZero) // truearr.map(callback[, thisArg]) // 每个值都调用一次函数并且返回新数组 * function twice(element, index, array)&#123;return element*element&#125; * arr.map(twice) // [1, 4, 9, 16]arr.reduce(callback,[initialValue]) // 将多维数组转为一维数组arr.some(callback[, thisArg]) // 测试元素是否通过指定测试arr.indexOf(searchElement[, fromIndex = 0]) // 返回满足条件的第一个索引，不存在返回-1 * arr.indexOf(3) // 2arr.lastIndexOf(searchElement[, fromIndex = arr.length - 1]) // 由后向前查找arr.forEach(callback[, thisArg]) // 对数组每个元素执行一次函数 3.5 ES2015(ES6)123456789101112131415161718192021222324252627282930313233343536Array.of(element0[, element1[, ...[, elementN]]]) // 创建新数组 * Array.of(3) // [3] * Array(3) // [undefined × 3] * Array.of([1,2,3]) // [Array[3]] * Array([1,2,3]) // [Array[3]]Array.from(arrayLike[, mapFn[, thisArg]]) // 从类数组对象或可遍历对象中创建数组 * Array.from(&apos;berg&apos;) // [&quot;b&quot;, &quot;e&quot;, &quot;r&quot;, &quot;g&quot;]arr.copyWithin(target, start, end) // 选定数组值，在一定范围内全部粘贴选定值 * arr.copyWithin(1,2,3) // [1, 3, 3, 4]arr.entries() // 返回新的数组迭代器（一定得复制给变量再迭代） * var newArr = arr.entries() * newArr.next().value // [0, 1] * newArr.next().value // [1, 2] * newArr.next().value // [2, 3] * newArr.next().value // [3, 4]arr.keys() // 返回新的数组迭代器arr.fill(value, start, end) // 用指定值填充一定范围数组 * arr.fill(0,1,3) // [1, 0, 0, 4]arr.filter(callback[, thisArg]) // 将满足条件的元素返回成新数组 * function isNotZero(element)&#123;return element!==0&#125; * arr.filter(isNotZero) // [1, 2, 3, 4]arr.find(callback[, thisArg]) // 返回满足条件的第一个值，不存在返回undefined * function isNotZero(element)&#123;return element!==0&#125; * arr.find(isNotZero) // 1arr.findIndex(callback[, thisArg]) // 返回满足条件的第一个元素的索引 * function isNotZero(element)&#123;return element!==0&#125; * arr.findIndex(isNotZero) // 0 3.6 ES2016123arr.includes(searchElement, fromIndex) // 判断数组是否包含指定值，返回true/false arr.includes(2) // true 总结 上一周一直在忙活Note这个小项目，现在已经上线了。以后会逐步增大项目复杂度。并且尝试用Vue和RN来分别对项目进行重构，后端则逐步接入Node.js和mongoDB。兼容性支持IE9及以上，根据IE7/8访客基数决定是否兼容。 接下来的时间就安心的总结JS和更博客吧。关于Note开发过程中遇到的问题，以及解决方案，等整理好了再发出来。 文章主要参考的站点 MDN 脚本之家 ES5 ES5新增数组方法 前端兼容性方案 Can I use W3Help quirksmode 前端兼容性不完全指南 也谈兼容性——通用hack方法/CSS兼容方案/js兼容方案全推送","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String）","date":"2017-03-06T05:09:51.000Z","path":"2017/03/06/前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String）/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录这是《前端总结·基础篇·JS》系列的第一篇，主要总结一下原型、原型链、构造函数及字符串。 12345678910111213141516一、原型链 1.1 原型（prototype） 1.2 原型链（__proto__） 1.3 构造函数（constructor）二、字符串使用 2.1 定义字符串 2.2 使用字符串三、常用技巧 3.1 字频统计四、方法列表 4.1 转换 4.2 修改 4.3 匹配 4.4 文本 4.5 其他 一、原型链更多有关原型链的思考，请见汤姆大叔的博客。 1.1 prototype（原型）给原型添加属性和方法，需要添加在对象上。这些属性和方法，会被后代继承。实现继承还有其他方法，更多请见幻天芒的博客。 1234String.prototype.bibi = &apos;die&apos; // 原型是作用于对象String上的var str = &apos;&apos;console.log(str.bibi) 1.2 __proto__（原型链）原型链中包含了此对象的所有方法。 123var str = &apos;&apos;console.log(str.__proto__) 1.3 constructor（构造函数）构造函数是一类具有某些相同属性事物的集合。在创建对象的时候，会将传过来的参数赋值到对象自身的属性上。父类的静态属性和方法会被子类继承。 1234567891011/* 定义汽车构造函数 */var Car = function(brand)&#123; this.brand = brand this.type = &apos;Car&apos;&#125;var BMW = new Car(&apos;BMW&apos;) // 创建BMW车型console.log(BMW.brand) // 显示品牌名str.__proto__.constructor // function String() &#123; [native code] &#125;str.__proto__.__proto__.constructor 二、字符串使用2.1 定义字符串字符串使用单引号或者双引号引起来。可以直接定义，也可以创建字符串对象。 123var str = &apos;I See U.&apos; // 直接定义字符串并且复制给变量var str = new String(&apos;I See U.&apos;) // 创建字符串对象并赋值 2.2 使用字符串字符串的下标从0开始，最后一个下标是字符串长度减1。访问字符串可以直接访问，或者对 123console.log(str) // 直接访问console.log(str[0]) // 通过下标访问 三、常用技巧3.1 字频统计首先把字符串中的词库提取出来（可以将字符串转成数组，再去重）。在去重的同时可以把次数统计出来。去重的更多方法，请见前端网。call用来改变this的指向，方法请见每天进步一点点！。 统计结果为0次，就是一次。统计函数还有待改善。功能上无问题，细节上还得继续优化。例如，标点符号和空格应该过滤掉。或者强化一下，统计词频。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var wordCount = function(str)&#123; /* 提取字库 */ var strSorted = str.split(&apos;&apos;).sort() // 字符串转数组并排序 var newArr = [] // 保存去重后的数据 countArr = [] // 保存统计结果，下标为出现的次数 /* 去重 */ var nextCount = 0 // 定义是否抵达下一个新词 var currentCount = 0 // 存储重复词的次数 for(x in strSorted)&#123; if(strSorted[x]!==newArr[newArr.length-1])&#123; nextCount = 1 // 标记已抵达新词 newArr.push(strSorted[x]) // 去重后的数据保存到newArr if(Array.isArray(countArr[currentCount]) == false)&#123; countArr[currentCount] = [] // 防止包括，先定义为数组 &#125; Array.prototype.push.call(countArr[currentCount],strSorted[x-1]) // 把统计结果保存在CountArr // console.log(&apos;if / currentCount:&apos;+currentCount) 调试计数器 currentCount = 0 // 重置上一次的计数 &#125; else&#123; if(nextCount === 1)&#123; currentCount+=1 // 补上一个计数 nextCount=0 // 重置抵达下一个的标记 &#125; currentCount+=1 // 计算器加一 // console.log(&apos;else / currentCount:&apos;+currentCount) 调试计数器 &#125; &#125; /* 展示数据 */ for(var i = countArr.length-1;i&gt;=0;i--)&#123; if(countArr[i]!==undefined)&#123; console.log(&apos;出现&apos;+i+&apos;次：&apos;+countArr[i]) &#125; &#125; return countArr&#125;/* 使用函数 */var str = &apos;今天的天气还是不错的，不出去走走走走走？&apos; // 定义测试用字符串wordCount(str) 四、方法列表为方便阅读，有如下准则： 参数中的[]代表可选参数。如substr(start[,length])中，length为可选参数。 本文对常用API做了精准分类，更加便于阅读。 需要让某些浏览器支持某些新功能，，可以使用腻子脚本（Polyfill），详见[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/ Reference/Global_Objects/String)。 定义字符串str为’I Love Javascript.’。下面的测试代码将在此基础上进行。 12var str = &apos;I Love Javascript.&apos; 4.1 转换字符串（通常在其他数据类型转换成字符串的时候用到） 123456* toString()（一般转换） str.toString() // &quot;I Love Javascript.&quot; [1,2,3].toString() // &quot;1,2,3&quot; 数组转成字符串* String(str)（强制转换） String(str) // &quot;I Love Javascript.&quot; 数组 123456789split([separator[,limit]])（第一个参数为分离的规则，第二个参数为分离后的数组个数） str.split() // [I Love Javascript.] str.split(&apos;&apos;) // [&quot;I&quot;, &quot; &quot;, &quot;L&quot;, &quot;o&quot;, &quot;v&quot;, &quot;e&quot;, &quot; &quot;, &quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;s&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;, &quot;.&quot;] str.split(&apos; &apos;) // [&quot;I&quot;, &quot;Love&quot;, &quot;Javascript.&quot;] str.split(&apos; &apos;,2) // [&quot;I&quot;, &quot;Love&quot;] str.split(/\\s*/) // [&quot;I&quot;, &quot;L&quot;, &quot;o&quot;, &quot;v&quot;, &quot;e&quot;, &quot;J&quot;, &quot;a&quot;, &quot;v&quot;, &quot;a&quot;, &quot;s&quot;, &quot;c&quot;, &quot;r&quot;, &quot;i&quot;, &quot;p&quot;, &quot;t&quot;, &quot;.&quot;] str.split(/\\s&#123;1&#125;/) // [&quot;I&quot;, &quot;Love&quot;, &quot;Javascript.&quot;] str.split(/\\s&#123;2&#125;/) // [&quot;I Love Javascript.&quot;] 链接 12345678ES6* link(url)（转成链接） str.link(&apos;z.cn&apos;) // &apos;&lt;a href=&quot;z.cn&quot;&gt;I Love Javascript.&lt;/a&gt;&apos;* anchor(name)（转成页内定位链接，又叫锚链接） str.anchor(&apos;top&apos;) // &apos;&lt;a name=&quot;top&quot;&gt;I Love Javascript.&lt;/a&gt;&apos; 4.2 修改切割 12345678910111213141516* substr(start[,length])（start参数可为负，第二个参数为长度） str.substr(2,3) // &apos;Lov&apos;（start为负时，IE需要使用polyfill）* substring(indexStart[,indexEnd])（参数皆不可为负，取值&gt;=0） str.substring(2,3) // &apos;L&apos;* slice(beginIndex[,endIndex])（参数皆可为负） str.slice(-8,-2) // &apos;ascrip&apos;* trim()（删除文本左右两边空格，文本中的空格不删除） str.trim() // &apos;I Love Javascript.&apos;* trimLeft(删除文本左边空格)* trimRight(删除文本右边空格) 拼接 1234567891011concat(string2[,string3,....stringN])（字符串拼接，可有多个参数） str.concat(&apos;Me Too.&apos;) // &apos;I Love Javascript.Me Too.&apos;ES6String.raw()（单行字符串，会转义\\n\\u000A等转义字符） let name = &apos;Bob&apos;;String.raw`Hi\\n$&#123;name&#125;!` // &apos;Hi\\nBob!&apos; String.raw`Hi\\n$&#123;2+3&#125;!`; // &apos;Hi\\n5!&apos; String.raw`Hi\\u000A!`; // &apos;Hi\\u000A!&apos; String.raw(&#123; raw: &apos;test&apos; &#125;, 0, 1, 2); // &apos;t0e1s2t&apos; 4.3 匹配搜索 1234567891011121314151617181920212223242526272829303132333435* indexOf(searchValue[,fromIndex])（大于length返回-1） str.indexOf(&apos;a&apos;) // 8 str.indexOf(&apos;a&apos;,20) // -1* lastIndexOf(searchValue[,fromIndex]) str.lastIndexOf(&apos;a&apos;) // 10 fromIndex小于0时转换为0 str.lastIndexOf(&apos;a&apos;,20) // 10 fromIndex大于length时搜索整个字符串 str.lastIndexOf(&apos;a&apos;, 9) // 8 使用了index，搜索完了右边，还要搜索左边* charAt(index) str.charAt(5) // e* charCodeAt(index) str.charCodeAt(5) // 101* String.fromCharCode(num1[,...[,numN]]) String.fromCharCode(101) // e 使用的是Unicode编码ES6* CodePointAt(index)* String.fromCodePoint(num1[,...[,numN]])* includes(searchString[,position])（判断文本是否存在的搜索，位置参数可选） str.includes(&apos;Love&apos;) // true（返回值为true/false）* startWith(searchstring[,position]) str.endsWith(&apos;I&apos;) // true str.endsWith(&apos;i&apos;) // false* endsWith(searchstring[,position]) str.endsWith(&apos;Javascript.&apos;) // true str.endsWith(&apos;Javascript&apos;) // false 正则 replace使用函数作为第二参数请见MDN 1234567891011121314151617181920212223242526272829303132* match(regexp)（匹配到返回结果，没有则返回null） str.match(/Lo/) // [&quot;Lo&quot;] str.match(/Los/) // null* search(regexp)（匹配到返回下标，没有则返回-1） str.search(/Lo/) // 2 str.match(/Los/) // -1* repacle(regexp|substr,newSubstr|function)（得到的是返回的新字符串，原字符串不变） str.replace(/Love/,&apos;like&apos;) // &apos;I like Javascript.&apos; str.replace(/Love/,&apos;like&apos;);str // &apos;I Love Javascript.&apos; var newStr = str.replace(/Love/,&apos;like&apos;);newStr // &apos;I like Javascript.&apos;精确匹配 数字 \\d 匹配0-9中任意数字，亦可表示成[0-9] 单词 \\w 匹配数字、大小写字母和下划线，亦可表示成[A-Za-Z0-9_] 字符 \\s 匹配空白字符（空格、水平或垂直制表符、换行、换页等），亦可表示成[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] 取反 \\D\\W\\S 这些表示的是对应小写字母的集合取反，比如\\D为[^0-9]，也就是只要不是0-9都可以匹配 边界 ^x，x$分别匹配字符首和尾。\\b，\\B分别匹配单词首和尾。 右值 x(?=y)为当x紧接着的一个字符是y则匹配。x(?!y)表示紧接着的不是y则匹配。 空白 \\t、\\v、\\f、\\r、\\n、[\\b],分别为水平制表符、垂直制表符、换页、回车、换行和退格。这些都是空白字符。模糊匹配 0个或以上 * 1个或以上 + 1个或0个 ? 这个或那个 x|y 非换行和回车 .按组匹配 最起码一组 &#123;1,&#125; 一组到三组 &#123;1,3&#125; 只要一组 &#123;1&#125; 4.4 文本状态 1234567891011* toUpperCase()（转成大写） str.toUpperCase() // I LOVE JAVASCRIPT.* toLowerCse()（转成小写） str.toLowerCase() // &apos;i love javascript.&apos;* toLocalUpperCase()/toLocalLowerCase()（本地化的大写和小写，一般不使用）ES6语法repeat(count)（让文本重复多次，参数为重复的次数，范围为&gt;=0。） str.repeat(2) // &apos;I Love Javascript.I Love Javascript.&apos; 修饰 1234567891011121314已废弃清单（不推荐使用）（以下皆用来生成HTML标签） sup() // &lt;sup&gt; 上标 sub() // &lt;sub&gt; 下标 bold() // &lt;b&gt; 粗体 big() // &lt;big&gt; 大号字体 small() // &lt;small&gt; 小号字体 strike() // &lt;strike&gt; 删除线 italics() // &lt;i&gt; 斜体 fixed() // &lt;tt&gt; 打印机字体 blink() // &lt;blink&gt; 闪烁字体 fintsize(number) // &lt;font size=&quot;&quot;&gt; 参数取值范围为1-7 fontcolor(color) // &lt;font color=&quot;&quot;&gt; 4.5 其他更多的用法和解释请见MDN。 123456789* valueOf() // 转换成字符串，默认自动调用，不可直接使用* toSource() // 自动调用* localeCompare()ES6* string[Symbol.iterator]* normalize() 结语本文部分参考W3School，主要参考MDN。另外，还参考了汤姆大叔、幻天芒、前端网和每天进步一点点！的博客。 汤姆大叔的深入理解JAVASCRIPT系列，貌似不错，留个标记，好好学。 前端网也不错，做个标记，好记得路。 附：ES6规范 | ES3规范 | ES5规范ecma-262/5.1/)","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"前端总结·基础篇·CSS（三）补充","date":"2017-03-01T11:27:16.000Z","path":"2017/03/01/前端总结·基础篇·CSS（三）补充/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录12345678910111213141516171819202122一、移动端 1.1 视口（viewport） 1.2 媒体查询（media query） 1.3 相对字体大小（rem/em）二、选择器 2.1 常用 2.2 关系 2.3 伪元素 2.4 伪类 2.5 优先级三、样式重置（reset） 3.1 常用重置 3.2 重置插件（Normalize.css）四、浏览器前缀 4.1 前缀由来 4.2 解决方案五、兼容性 5.1 IE条件注释 5.2 IE hack 5.3 指定渲染模式五、CSS库 一、移动端移动端还没有上车。先来总结一下三个基本的移动端开发特性：视口（viewport）、媒体查询（@media）和相对字体大小。 1.1 视口（viewport）加上视口之后，页面将会自动裁剪成适合移动页面的大小。 123456&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot;&gt;width=device-width // 把页面宽设置成设备一样initial-scale=1.0 // 初始缩放为1.0user-scalable=no // 不允许用户缩放（此处有坑，有时会无效） 1.2 媒体查询（media query）以下只是对媒体查询使用的一个演示。实际中我们常用媒体查询来根据不同宽度的设备显示不同的布局。 123456789101112131415161718192021/* HTML */&lt;div class=&quot;media&quot;&gt;meida&lt;/div&gt;/* CSS */.media &#123; background-color: gray; color: white;&#125;@media screen and (max-width:1000px) &#123; .media &#123; background-color: red; &#125;&#125;@media screen and (max-width:800px) &#123; .media &#123; background-color: orange; &#125;&#125; 1.3 相对字体大小（rem/em）rem是相对于根字体的大小，em是相对于父级的字体大小。 123456789101112131415/* HTML */&lt;div class=&quot;rem&quot;&gt;rem&lt;/div&gt;/* CSS *//* 根字体在html而不是body中 */html &#123; font-size: 60px; /* 修改根字体，对应div中的字体会改变 */&#125;.rem &#123; font-size: 1.2rem;&#125; 二、选择器2.1 常用标签（tag）、id和类（class）都是常用的选择器。其中class最为常用。 123456789// id在页面中是唯一的，class的属性可以有多个&lt;p id=&quot;mark&quot; class=&quot;mark important&quot;&gt;mark&lt;/p&gt;&lt;p class=&quot;mark todo&quot;&gt;have a lunch&lt;/p&gt;p &#123;color:red;&#125; // 标签选择器#mark &#123;color:red;&#125; // id选择器.mark &#123;color:red;&#125; // 类选择器 2.2 关系后代（parent child-child） 子代（parent&gt;child） 兄弟（+） 相邻（~）。 兄弟选择器常用来制作，导航栏中间的一条边框线。 12345678910111213141516171819202122&lt;ul&gt; &lt;li class=&quot;brother&quot;&gt;&lt;a&gt;one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;two&lt;/li&gt; &lt;li&gt;three&lt;/li&gt;&lt;/ul&gt;ul li &#123;color:red;&#125; // 后代选择器，one、two和three都变成红色ul&gt;li &#123;color:red;&#125; // 子代选择器，two和three变成红色.brother+li &#123;color:red;&#125; // 兄弟选择器，two变成红色.brother~li &#123;color:red;&#125; // 相邻选择器，two和three变成红色中间线示例li &#123; float: left; list-style-type: none; padding: 5px;&#125;li+li &#123; border-left: 1px solid red;&#125; 2.3 伪元素伪类有::before、::after、::selection、::first-line、::first-letter。 其中::before常用来制作三角形和登陆框左边的图标。更多请见kingkit。 12345678910111213141516171819202122232425262728293031323334/* HTML */&lt;div class=&quot;triangle&quot;&gt;triangle&lt;/div&gt;/* CSS */.triangle &#123; position: relative; border: 1px solid red; padding: 2px 4px; width: 60px; height: 20px; margin-left: 10px; border-radius: 10%; // 设置矩形圆角&#125;.triangle::before,.triangle::after &#123; content: &quot;&quot;; position: absolute; top: 7px; left: -10px; width: 0; height: 0; border-style: solid; border-color: transparent red transparent transparent; // 右边框设置为红色 border-width: 5px 10px 5px 0; // 左边框设置为0&#125;.triangle::after &#123; left: -9px; border-right-color: white; // 设置三角形内容为白色&#125;.triangle::selection &#123; color: red; // div内选中的部分会变成红色&#125; 2.4 伪类LVHA（:link,:visited,:hover,:active）、:focus、lang、first-child（last-child,nth-child(n)） 1234div:first-child &#123;&#125;div:nth-child(5) &#123;&#125;div:last-child &#123;&#125; 2.5 优先级优先级最高的是设置了!important的元素，其次看元素的权重。权重相同时看谁离HTML更近（内嵌&gt;内链&gt;外链），近的优先级更高。 权重分配是attr：1000，id：100，class：10，tag：1。当有多种选择器组合的时候，他们的权重之和就是总权重。权重大的优先级高。 123display: none!important; // 优先级最高，IE6不支持同一选择符中的!important.parent &gt; div &#123;&#125; // 权重计算 10+1=11 同级的按照就近原则（内嵌&gt;内连&gt;外链），越近优先级越高优先级最高 三、样式重置（reset）3.1 常用重置123456* &#123;box-sizing:border-box;&#125; /* IE8+ */body &#123;margin:0;&#125; /* 去除边距 */ul &#123;margin:0;padding-left:0;&#125; /* 去除边距和左填充 */li &#123;list-style-type:none;&#125; /* 去除列表的圆点 */a &#123;text-decoration:none;&#125; /* 去除下划线 */ 3.2 重置插件（Normalize.css,IE8+）当然，你也可以不自己写重置样式，使用插件制动帮你完成。 四、浏览器前缀想要使用未标准化的新特性，往往伴随着一大堆兼容前缀。各浏览器使用自己的私有前缀实现新功能，我门在写完了兼容属性之后，还要加上一条标准属性。等到属性标准化之后我们就不需要重新添加标准属性了。 12345678div&#123; transition: width 2s; -moz-transition: width 2s; /* Firefox 4 */ -webkit-transition: width 2s; /* Safari 和 Chrome */ -o-transition: width 2s; /* Opera */&#125; 4.1 前缀由来在实验性功能尚未标准化之前，浏览器厂商为了开发者能尽快的体验这些新特效。通过带前缀的CSS属性使得这些功能可以直接被使用。 待到标准化之后，则可以通过不带前缀的属性设置样式。但是对于没有更新浏览器的用户来说，样式依旧需要通过私有属性访问。 这样，你不得不写N条兼容代码。chrome（-webkit-）、firefox(-moz-)和opera(-o-)。safari和chrome一样，私有属性前缀也是-webkit-。 4.2 解决方案这时，你需要的是一个Autoprefixer或者-prefix-free。 五、兼容性除了手写IE兼容性，你也可以直接使用IE9.js自动处理IE6-9的bug。另外，让IE6-9支持的支持圆角、背景渐变、边框图片、盒阴影、rgba等可视化的功能可以用CSS3PIE。让IE6-8支持媒体查询可以使用Respond.js。IE6-7支持CSS3 box-sizing可以使用borderBoxModel.js。IE6-8支持:first-child等高级CSS选择符，可以用selectivizr。让IE8及以下的浏览器支持H5新元素，可以用html5shiv.js。 5.1 IE条件注释这类代码只有IE会解析，其他浏览器会作为注释处理。更多请见天堂的旋转木马。 12345678910&lt;!--[if IE 6]&gt; &lt;script type=&quot;text/javascript&quot; scr=&quot;IE6.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt;if &lt;条件&gt; IE &lt;版本&gt;条件：gt/gte/lt/lte/!（大于/大于等于/小于/小于等于/非）版本：5.5/6/7/8!IE 通常连在一起 5.2 IE hack为针对不同IE浏览器进行样式修改，可以使用css hack。更多请见freshlover。 123456789指定版本：IE6(_),IE7(+),IE8(/),IE9(:root 9)指定范围：IE6-7(*),IE8-10(\\0),IE9-10(\\9\\0),IE All(\\9).hack&#123; _color:red; /* IE6 */ color:red\\0; /* IE8-10 */&#125;:root .hack&#123;color:red\\0;&#125; /* IE9 */ 5.3 指定渲染模式你可以为IE指定渲染模式，当用户安装谷歌插件GCF之后，将会强制页面使用chrome模式渲染。更多请见脚本之家。 12345&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=7&quot; /&gt; // IE8-9使用IE7模式渲染&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=8&quot; /&gt; // IE8-9使用IE8模式渲染&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;edge&quot; /&gt; // IE8-9使用IE最高版模式渲染&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; // 安装GCF之后，IE使用chrome模式渲染 五、CSS库为了方便快速的再次实现需要的效果，把常用的功能封装起来。通过设置class的方式，使用封装好的css库。更多请见深度开源。 CSS3悬浮效果（Hover.CSS）、提示（HINT.css）、进度（progress.js）、加载动画（css-loaders）、按钮（Buttons）、预处理（less,sass）、界面（Bootstrap）。 总结这一节主要参考的书籍有：《CSS设计指南》和《CSS揭秘》。主要参考的网站和博客有梦之都、脚本之家、W3School、深度开源、kingkit、天堂的旋转木马和freshlover。另外还有一些平时的积累。 未来半个月的更新频率不能保证了，快与慢完全说不准。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://bergwhite.github.io/tags/CSS/"}]},{"title":"前端总结·基础篇·CSS（二）视觉","date":"2017-02-24T13:08:12.000Z","path":"2017/02/24/前端总结·基础篇·CSS（二）视觉/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录 12345678910111213141516171819202122232425262728一、动画（animation）(IE10+)（CSS3） 1.1 定义动画 1.2 引用动画 1.3 多个动画 1.4 更多属性二、过渡（transition）（IE10+）（CSS3） 2.1 定义首尾 2.2 应用过渡 2.3 多个过渡 2.4 更多属性三、转换（transform）（IE10+,-ms-,-webkit-,-moz-,-o-）（CSS3） 3.1 2D转换（-ms- for IE9） 3.2 3D转换（not opera）四、圆角、阴影和透明的实践（CSS3） 4.1 圆角（border-radius）（IE9+） 4.2 阴影（shadow）（box-shadow IE9+ text-shadow IE10+） 4.3 透明度（opacity）五、可缩写属性 5.1 背景（background） 5.2 字体（font） 5.3 边框（border）（border-image IE11+） 5.4 填充和边距（padding/margin）六、滤镜（filter）（notIE,-webkit-）七、补充 7.1 自定义鼠标指针（cursor） 7.2 Canvas 7.3 SVG 7.4 WebGL 一、动画（animation）(IE10+,-webkit-,-moz,-o-)（CSS3）动画抵达的过程是连续的，还原的过程是突发的。放完了就还原，就是这么任性。 1.1 定义动画定义动画可以用from-to的两个定点形式，也可用百分比（0%、50%、100%）的多个定点形式。 123456789101112131415/* 定义动画 */@keyframes toRight &#123; from &#123; left: 0px; top: 0px; background-color: red; &#125; to &#123; left: 130px; top: 0px; background-color: blue; &#125;&#125; 1.2 引用动画我们先定义一个div块，class为animation。然后对这个div块引用动画效果。 12345678910111213141516171819/* HTML部分 */&lt;div class=&quot;animation&quot;&gt;&lt;/div&gt;/* 定义div块的默认样式 */.animation &#123; position: absolute; width: 100px; height: 100px; background-color: red;&#125;/* 引用动画 当鼠标悬于div块上方时触发动画效果 */.animation:hover &#123; animation: toRight 5s;&#125; 1.3 多个动画设置多个帧（@keyframes）,使用不同的名字。在引用动画的时候不同的帧用逗号隔开。 12animation: toRight 5s,toTop 5s; 1.4 更多属性下面是一个完整的属性应用和属性说明。 1234567891011animation:walk 2s ease 1s 2 normal running forwards;animation-name:keyframename/none;animation-duration:time;animation-timing-function:linear/ease/ease-in/ease-out/ease-in-out/cubic-bezier(n,n,n,n);animation-delay:time;animation-iteration-count:n/infinite;animation-direction:normal/alternate;animation-play-state:paused/running;animation-fill-mode:none/forwards/backwards/both; 二、过渡（transition）(IE10+,-webkit-,-moz,-o-)（CSS3）过渡一直是连续的，无论是抵达的过程，还是还原的过程。 2.1 定义首尾123456789101112131415161718/* HTML */&lt;div class=&quot;transition&quot;&gt;&lt;/div&gt;/* 定义首 默认样式 */.transition &#123; width: 100px; height: 100px; background-color: red;&#125;/* 定义尾 目标样式 */.transition:hover &#123; width: 200px;&#125; 2.2 应用过渡1234567.transition &#123; width: 100px; height: 100px; background-color: red; transition: width 2s; /* 只需添加这一条 */&#125; 2.3 多个过渡应用多个过渡的时候用逗号隔开，或者直接设置应用过渡效果的属性为all。 123456transition: width 5s,height 5s;或transition: all 5s; 2.4 更多属性1234567transition:width 2s ease 1s;transition-property:none/all/property;transition-duration:time;transition-timing-function:linear/ease/ease-in/ease-out/ease-in-out/cubic-bezier(n,n,n,n);transition-delay:time; 三、转换（transform）（IE10+,-ms-,-webkit-,-moz-,-o-）（CSS3）3.1 2D转换（-ms- for IE9）以下没有演示矩阵效果，更多请见张鑫旭。下图的效果依次是缩放、旋转、斜拉和移动，参数和下方的参数保持一致，展示的过程是用animation做的。 123456缩放 transform：scale(2,2); // 两个参数分别是宽和高缩放的比例旋转 transform：rotate(180deg);斜拉 transform：skew(30deg,30deg);移动 transform：translate(50px,-50px);矩阵 transform：matrix(n,n,n,n,n,n); // 3*3矩阵 6个参数 3.2 3D转换（not opera）123456789101112131415缩放：transform:scale(x,y)/scaleX(x)/scaleY(y)/scaleZ(z)/scale3d(x,y,z)旋转：transform:rotate(angle)/rotateX(angle)/rotateY(angle)/rotateZ(angle)/rotate3d(x,y,zangle)斜拉：transform:skewX(angle)/skewY(angle)/skew(x-angle,y-angle)移动：transform:translate(x,y)/translateX(x)/translateY(y)/translate3d(x,y,z)透视：perspective(100) 默认单位是px，表示观察者离物体的距离（-webkit-）矩阵：transform:matrix3d(); 4*4矩阵 16个参数其他：transform:none;属性transform-origin:x-axis/y-axis/z-axis;transform-style:flat/preserve-3d;（not IE）perspective:number/none;perspective-origin:x-axis/y-axis;backface-visibility:visibility/hidden; 四、圆角、阴影和透明的实践（CSS3）4.1 圆角（border-radius）（IE9+）下面是用过渡和圆角制作的一个按钮。 1234567891011121314151617181920/* HTML */&lt;a href=&quot;#&quot; class=&quot;border-radius&quot;&gt;HELLO&lt;/a&gt;/* CSS */.border-radius &#123; border: 1px solid red; border-radius: 10px 0 10px 0; // 设置圆角（四个值分别为top-left、top-right、bottom-right和bottom-left） width: 60px; padding: 10px; text-align: center; transition: all .3s ease-in-out; // 设置过渡效果 text-decoration: none; // 去除链接下划线&#125;.border-radius:hover &#123; background-color: red; color: white;&#125; 4.2 阴影（shadow）（box-shadow IE9+ text-shadow IE10+）给按钮加上盒阴影和文本阴影。 12345678910111213141516171819202122/* HTML */&lt;a href=&quot;#&quot; class=&quot;border-radius&quot;&gt;HELLO&lt;/a&gt;/* CSS */.border-radius &#123; border: 1px solid red; border-radius: 10px 0 10px 0; width: 60px; padding: 10px; text-align: center; transition: all .3s ease-in-out; text-decoration: none;&#125;.border-radius:hover &#123; background-color: red; color: white; box-shadow: -10px -10px 5px gray; // 盒子阴影（四个值分别是x轴、y轴、模糊距离和颜色） text-shadow: -5px -5px 3px black; // 文本阴影&#125; 4.3 透明度（opacity）再加上透明度。默认透明度为0.5，悬浮在按钮上后变为1.0. 1234567891011121314151617181920212223242526/* HTML */&lt;a href=&quot;#&quot; class=&quot;border-radius&quot;&gt;HELLO&lt;/a&gt;/* CSS */.border-radius &#123; border: 1px solid red; border-radius: 10px 0 10px 0; width: 60px; padding: 10px; text-align: center; transition: all .3s ease-in-out; text-decoration: none; opacity: .5; // 设置默认透明度为0.5&#125;.border-radius:hover &#123; background-color: red; color: white; box-shadow: -10px -10px 5px gray; text-shadow: -5px -5px 3px black; opacity: 1; // 设置按钮悬浮之后的透明度为1&#125;/* 除了opacity，rgba同样具有透明度属性 */ 五、可缩写属性5.1 背景（background）制作精灵图（sprite）可以用background-color:url() -20px -20px;，然后将元素的width和height设置成小图的大小。 123456789101112131415background:red url(laughcry.gif) repeat top left;background-color:color/transparent;background-image:url()/none/inherit;background-repeat:repeat/repeat-x/repeat-y/no-repeat/inherit;background-position:left top/center top/right top...;background-attachment:scroll/fixed/inherit;background-size:length/percentage/cover/contain; // cover为覆盖最小定位区域，contain为最大background-clip:border-box/padding-box/content-box; // 指定定位区域background-origin:border-box/padding-box/content-box; // 指定绘画区域CSS3多背景：（-image:url(bg.jpg),url(dog.jpg)）定位源（-origin:content-box/padding-box/border-box）显示区域（-clip:content-box;）和尺寸（-size(80px 60px)） 渐变（gradient）（IE10+,-webkit-,-o-,-moz-)（CSS3） 线性渐变（linear-gradient） 12345* background:linear-gradient(red,blue,green)* 默认为从上到下渐变，to right（前缀写法中皆为left）可以设置从左到右渐变，to bottom right则对角线渐变（前缀写法中webkit为left top），180deg则可以设置按照角度渐变；* background:linear-gradient(to right,red 10%,blue 50%,green 70%)* background:linear-gradient(rgba(220,220,220,0),rgba(220,220,220,1)) 径向渐变（radial-gradient） 12345* background:radial-gradient(red,blue,green)* 颜色值前面可以设置形状elipse/circle（椭圆/圆）默认为elipse* background:radial-gradient(60% 55%,closest-side,red,blue,green)* 以上的参数还有farthest-side,closest-corner,farthest-corner, 5.2 字体（font）文字溢出时可以使用word-break:break-all;进行字母级截断，也可以使用word-wrap:break-word;进行单词级的截断。 1234567891011121314151617181920212223font:italic bold 1.2em/1.2 Arial,sans-serif;font-style:normal/italic/oblique/inherit;font-weight:normal/bold/bolder/lighter/100...900 400为normal 700为bold/inherit;font-size:xx-small/x-small/small/medium/large/x-large/xx-large/smaller/larger/length/%/inherit;line-height:normal/number/length/%/inherit;font-family:family-name/generic-family;CSS3@font-face用来设置自定义字体。留坑，以后再来好好总结一下。以下代码直接粘贴自[菜鸟教程](http://www.runoob.com/try/try.php?filename=trycss3_font-face_rule)。@font-face&#123; font-family: myFirstFont; src: url(&apos;Sansation_Light.ttf&apos;) ,url(&apos;Sansation_Light.eot&apos;); /* IE9 */&#125;div&#123; font-family:myFirstFont;&#125; 5.3 边框（border）（border-image IE11+）outline和border类似，但是不占用布局空间。 1234567border:1px solid red; // 值分别为border-width、border-style和border-colorborder-style:none/hidden/dotted/dashed/solid/double/groove/ridge/inset/outset/inherit;CSS3border-image:url() 30 30 stretch;（round为边框重复，stretch为边框拉伸） 5.4 填充和边距（padding/margin）垂直方向的margin会合并，水平方向的不会。实际显示的margin是两者中较大的那个。 12padding:1px 2px 1px 2px;（top/right/bottom/left） 六、滤镜（filter）（notIE,-webkit-）以下作为参考手册。 123456789101112* 透明 filter:opacity(50%);* 阴影 filter:drop-shadow(10px 10px 5px red);* 模糊 filter:blur(5px);* 对比度 filter:contrast(200%);* 饱和度 filter:saturate(800%);* 灰度 filter:grayscale(100%);* 深褐色 filter:sepia(100%);* 亮度 filter:brightness(200%);* 色相旋转 filter:hue-rotate(90deg);* 反转输入 filter:invert(100%);* 多值空格隔开 filter:filter:opacity(50%) blur(5px); 七、补充7.1 自定义鼠标指针（cursor）12cursor:pointer/help/wait/text/move/crosshair; 7.2 Canvas待到总结js的时候，再一并总结。 7.3 SVGSVG全称为可缩放矢量图像（Scalable Vector Graphics），参考教程有W3School和W3CPlus。成熟的库有D3.js，常用来进行数据可视化。以后学习，留坑。 7.4 WebGLWebGL全称为网页图像库（Web Graphics Library）。成熟的库有three.js，常用来基于web的3D制作。以后学习，留坑。 总结本文主要参考W3School，部分来自《CSS设计指南》和平常遇到问题时的一些总结，少部分来自菜鸟教程。GIF制作工具使用的是ScreenToGif 1.4.2。 码这篇文章码了好久啊，部分内容由于懒，就没有完整的写出来。 这是前端总结的第二篇文章，进度还是挺慢的。大概过了5天，才更新到第二篇。那我都在干啥呢？在总结JS啊。当然，只是做了大概的总结，并没有写成很详细的文档。因此，CSS基础篇的文档更新奇慢，接下来要做的事情就是提升更新的速度（保证质量的前提下）。Fighting。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://bergwhite.github.io/tags/CSS/"}]},{"title":"前端总结·基础篇·CSS（一）布局","date":"2017-02-19T15:42:25.000Z","path":"2017/02/19/前端总结·基础篇·CSS（一）布局/","text":"前端总结系列 前端总结·基础篇·CSS（一）布局 前端总结·基础篇·CSS（二）视觉 前端总结·基础篇·CSS（三）补充 前端总结·基础篇·JS（一）原型、原型链、构造函数和字符串（String） 前端总结·基础篇·JS（二）数组深拷贝、去重以及字符串反序和数组（Array） 前端总结·基础篇·JS（三）arguments、callee、call、apply、bind及函数封装和构造函数 前端总结·基础篇·JS（四）异步请求及跨域方案 前端总结·工具篇·管理（一）常用模块化方案 目录 12345678910111213一、显示（display） 1.1 盒模型（box-model） 1.2 行内元素（inline） &amp; 块元素（block） 1.3 行内块元素（inline-block IE8+ IE6-7/tools） 1.4 flex（IE11+ IE10/-ms-） 1.5 none二、位置（position）三、补充 3.1 浮动（float） 3.2 层叠（z-index） 3.3 溢出（overflow） 3.4 resize（notIE）（CSS3） 3.5 分栏（column）（IE10+ notOperaMini）（CSS3） 一、显示（display）1.1 盒模型（box-model）看图了解盒模 盒模型包括内容（content）、填充（padding）、边框（border）、边距（margin）。我们给元素设置的高度，是内容（content）的高度。再给元素添加填充（padding），元素看起来会更高。 以下是一个盒模型的演示实例，在谷歌浏览器中查看盒模型可以使用 右键&gt;属性&gt;Computed 的方式进行查看。 123456&lt;p class=&quot;box-model&quot;&gt;box-model&lt;/p&gt;.box-model &#123; border: 1px solid red; padding: 20px;&#125; 以边框为界的盒模型 有些时候，我们不希望给元素添加填充（padding）时，元素的高度会改变，这样不利于我们进行布局。可以把元素的盒模型，设置成以边框（border）为界的盒模型（box-sizing:border-box;）。在IE的怪异模式下，默认使用了这种盒模型。 下面是一个示例。 12345678&lt;div class=&quot;box-model&quot;&gt;box-model&lt;/div&gt;.box-model &#123; box-sizing: border-box; /* 设置成以边框为界的盒模型 */ border: 1px solid red; height: 80px; padding: 10px;&#125; 1.2 行内元素（inline） &amp; 块元素（block）布局一般都用块元素 块元素可以设置宽高，默认占据一行。行内元素不能设置宽高，宽度由其内容决定。 块元素默认没高度，有内容才会有高度。行内元素默认没高度和宽度，有内容才会有。行内元素虽然不能设置宽高，但是设置成绝对定位（absolute）后，可以设置宽高。（定位在第二节讲） 12块元素：div p ul li table form html5(header section footer)。行内元素：a font(em strong i) img span。 块元素可以变成行内元素 我们通常将li变成行内元素制作导航栏。 123456789&lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;文章&lt;/li&gt; &lt;li&gt;留言&lt;/li&gt;&lt;/ul&gt;.nav li &#123; display: inline;&#125; 一行只有一个块元素 但是，行内元素可以有多个。 空的块元素将在布局中消失 在调试页面的时候想要显示元素在布局中的位置，我们通常会给元素添加一个高度。 行内元素内容为空也会在布局中消失（不推荐为空）。 1.3 行内块元素（inline-block IE8+ IE6-7/tools）兼容性是支持&gt;=IE8，IE6-7请参见专注WEB前端开发。 清除两元素间隙 两元素间隙来源于元素间的空格，拼接元素即可消除。也可以用过使用模板来消除。更多讨论请见知乎。 12345&lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;首页&lt;/li&gt;&lt;li&gt; 文章&lt;/li&gt;&lt;li&gt; 留言&lt;/li&gt;&lt;/ul&gt; 特殊情况下的元素对齐 三个li并列，都设置成inline-block。当对最左边的元素设置display:none;时，其他两个li会下沉到容器的底部。此时，需要对这两个li设置顶部对齐（vertical-align:top;）。 123456789&lt;ul class=&quot;nav&quot; id=&quot;nav&quot;&gt; &lt;li class=&quot;left&quot;&gt;&lt;div class=&quot;hidden&quot;&gt;首页&lt;/div&gt;&lt;/li&gt; &lt;li class=&quot;center&quot;&gt;&lt;div&gt;文章&lt;/div&gt;&lt;/li&gt; &lt;li class=&quot;right&quot;&gt;&lt;div&gt;留言&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;.hidden &#123;display: none;&#125;.left &#123;height: 50px;&#125;.center,.right &#123;vertical-align: top;&#125; 1.4 弹性盒子（flex IE11+ IE10/-ms-）兼容性是支持&gt;=IE11，IE10需要添加浏览器私有前缀（-ms-）。 使用弹性布局 使用了弹性布局，float clear vertical将失效。更多请见阮一峰的博客。 12display:flex; // 块元素用display:inline-flex; // 行内元素用 弹性布局设置 这些就暂时当作参考手册吧。 123456789101112flex-direction:row/row-reverse/column/column-reverse; // 方向flex-wrap:nowrap/wrap/wrap-reverse; // 换行flex-flow:direction/wrap; // 方向和换行的简写，默认为flex-flow:row nowrap;justify-content:flex-start/center/flex-end/space-between/space-around; // 主轴（默认为水平轴）align-items：flex-start/center/flex-end/baseline/stretch; // 交叉轴align-contents:flex-start/center/flex-end/space-between/space-around/stretch; // 多条轴线的对齐方式（单条无效）order:number; // 顺序（默认为0）flex-grow:number; // 宽度有余时放大比例（默认为0）flex-shrink:number; // 宽度有余时缩小比例（默认为1）flex-basis:number/auto; // 分配多余空间前，项目占据的主轴空间（默认auto）flex:grow/shrink/basis; // grow shrink basis三个属性的缩写align-self:auto/flex-start/center/flex-end/baseline/stretch;; // 单个项目的对齐方式，可覆盖align-items（默认auto） 主轴（justify-content）只能居中单行元素 那多行怎么办呢？我们可以把多行嵌套在一个div中，构造出单行元素。 下面是一个水平和垂直居中的一个实例。 1234567891011121314&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt; &lt;p&gt;两行都会&lt;/p&gt; &lt;p&gt;居中&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;.parent &#123; display: flex; /* 使用flex布局 */ align-items: center; /* 交叉轴居中 */ justify-content: center; /* 主轴（默认为水平轴）居中 */ background: red; height: 200px;&#125; 1.5 none隐藏元素 以下两种方法都可以隐藏元素，但是display:none;会清除原本占用的布局空间。 12visibility:hidden; // 隐藏元素display:none; // 隐藏元素并清除原本占用的布局空间 二、位置（position）绝对（absolute）、相对（relative）和固定（fixed）定位，都可以使用top，right，left，bottom元素。但是表示的意义却各不相同。 清除布局空间的定位（absolute fixed） 固定定位（fixed）不会随着鼠标的滚动而改变位置。他真的是固定屏幕的某一个位置的，比较常见的是网页右下角的广告。 绝对定位（absolute）的定位原点是非默认定位（static）的父节点。可以是absolute fixed relative，如果父节点没有这些，那定位原点就是body了。使用了这两种定位中的一种，元素原本占用的布局空间将会消失（脱离文档流）。 下面是绝对定位（absolute）的一个例子。左图是默认布局，右图是使用绝对定位（absolute）之后的（元素原本的布局空间被清除）。 1234567891011121314&lt;p class=&quot;border&quot;&gt;I&apos;m in front of you.&lt;/p&gt;&lt;div class=&quot;parent&quot;&gt;Hello&lt;/div&gt;&lt;p class=&quot;border&quot;&gt;I&apos;m next to you.&lt;/p&gt;.border &#123; border: 1px solid blue;&#125;.parent &#123; position: absolute; left: 20px; top: 20px; background-color: red; padding: 5px;&#125; 保留布局空间的定位（relative） 元素原本占用的布局空间依旧保留在文档流中。 相对定位（relative）相对原有位置定位。把上例中的absolute改成relative即可看到效果。使用这种方法，元素原本占用的布局会保留。 默认定位 默认定位为static。 巧用relative+absolute定位 父级采用relative，子代采用absolute。则子代的定位原点变为父级元素的左上角。 三、补充3.1 浮动（float）刚开始做页面的时候，还不知道浮动用了之后得清除，只气的想要砸键盘。现在好多了，知道了点技巧。更多技巧请见Tomson。 清除浮动（.clear） 这种方法需要在浮动元素后面添加一个空的节点，然后写上clear属性。兼容IE6需要添加zoom:1;。 1234567891011121314151617&lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;文章&lt;/li&gt; &lt;li&gt;留言&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;!--用来清楚浮动的空元素--&gt;&lt;p&gt;我是另外一行&lt;/p&gt;.nav li &#123; background-color: red; float: left; list-style-type: none;&#125;.clear &#123; clear: both; zoom:1; /* IE 6 */&#125; 清除浮动（overflow:hidden;） 使用这种方法意味着，浮动元素得有一个父元素，并给父元素添加overflow:hidden;属性。 123456789101112131415&lt;ul class=&quot;nav&quot;&gt; &lt;li&gt;首页&lt;/li&gt; &lt;li&gt;文章&lt;/li&gt; &lt;li&gt;留言&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我是另外一行&lt;/p&gt;.nav li &#123; background-color: red; float: left; list-style-type: none;&#125;.nav &#123; overflow: hidden;&#125; 文字环绕 浮动元素的另外一个妙用是实现文字环绕。 1234567891011121314&lt;div class=&quot;article&quot;&gt; &lt;div class=&quot;photo&quot;&gt;&lt;/div&gt; &lt;p&gt;这段文字很长，是用来测试文字环绕的。图片的占位将用div块来模拟。这段文字很长，是用来测试文字环绕的。图片的占位将用div块来模拟。&lt;/p&gt;&lt;/div&gt;.article &#123; width: 200px;&#125;.photo &#123; width: 60px; height: 60px; background-color: red; float: right;&#125; 3.2 层叠（z-index）层叠可以控制元素的上下放置关系。值越大越上面。 123456789101112131415161718&lt;div class=&quot;z zOne&quot;&gt;&lt;/div&gt;&lt;div class=&quot;z zTwo&quot;&gt;&lt;/div&gt;.z &#123; position: absolute; top: 200px; left: 200px; width: 60px; height: 60px; background-color: red; opacity: .5; /* 设置透明度为0.5 */&#125;.zTwo &#123; top: 220px; /* 和第一个块错开以看到效果 */ left: 220px; background-color: blue; opacity: .5;&#125; 3.3 溢出（overflow）当页面内存在多个业内选项卡的时候，从一个没有右边滚动条的页面达到一个有滚动条的页面，将会产生页面跳动。解决办法是默认设置显示右边的滚动条。 1overflow-x:visibility; 3.4 resize（notIE）（CSS3）定义用户是否可调整当前元素的边框大小。 1resize: horizontal（水平）/vertical（垂直）/both/none/inherit; 3.5 分栏（column）（IE10+ notOperaMini）（CSS3）兼容性是IE&gt;=10，不支持opera mini。更多请见菜鸟教程。 1234567&lt;p&gt;这一段文字用来测试分栏。这一段文字用来测试分栏。这一段文字用来测试分栏。&lt;/p&gt;p &#123; width: 200px; /* 把段落的宽度设短一点，便于效果的展现 */ column-count: 3; /* 设定需要分几栏 */ column-gap: 20px; /* 设定两栏间隔 */&#125; 结语这一节主要参考了学习CSS布局，阮一峰的博客，Tomson，专注WEB前端开发，菜鸟教程，知乎和我在看的一本书《CSS设计指南》。 第一次写前端方面的长文章。写了改，改了写，然后继续改，又继续写。如此循环往复，只为让用词用句更加恰当一些。文中有什么不恰当的地方，还望指出。","tags":[{"name":"CSS","slug":"CSS","permalink":"https://bergwhite.github.io/tags/CSS/"}]},{"title":"JavaScript API Console","date":"2017-01-04T14:45:41.000Z","path":"2017/01/04/JavaScript-API-Console/","text":"1.Web API #Console @MDN 2.console #Console @whatwg 3.console #Console @Google 4.console对象 #Console @阮一峰 5.Console #Console @Opera 12345678910111213141516171819202122232425262728速查1 不同意义的输出语句 1.1 console.log() 1.2 console.info() 1.3 console.error() 1.4 console.warn() 1.5 console.debug() // 不推荐使用2 用占位符标记特殊变量 2.1 %s（字符） 2.2 %f（浮点型） 2.3 %d / %i（整数） 2.4 %o（对象） 2.5 %c（样式）3 其他输出语句 3.1 console.clear() // 清除控制台 3.2 console.trace() // 堆栈跟踪 3.3 console.assert() // maybe try later 3.4 console.count() // maybe try later 口 3.5 console.table() // 用表格来显示数据 口 3.6 console.group() // 输出结构化信息 console.groupCollapsed() // 输出结构化信息（默认折叠） console.groupEnd() // 本层结构结束（最多三层） 3.7 console.time() // 标记定时器 console.timeEnd() // 结束并且显示所用时间 3.8 console.dir() // 非标准特性 3.9 console.dirxml() // 非标准特性 示例 不同意义的输出语句 1console.log(&apos;好奇心是学习一门知识的源动力&apos;) 用占位符标记特殊变量 1console.log(&apos;%cExample&apos;,&apos;color:red&apos;) 其他输出语句 123456789101112131415outer()function outer()&#123; function inner()&#123; console.trace() &#125; inner()&#125;console.group()console.log(&apos;输出结构化信息&apos;)console.groupEnd()console.time()console.log(&apos;正在计时...&apos;)console.timeEnd(&apos;计时结束&apos;)","tags":[{"name":"JS","slug":"JS","permalink":"https://bergwhite.github.io/tags/JS/"}]},{"title":"常用的14种HTTP状态码速查手册","date":"2016-12-20T05:59:51.000Z","path":"2016/12/20/常用的14种HTTP状态码速查手册/","text":"分类 123451xx \\&gt; Information（信息） // 接收的请求正在处理2xx \\&gt; Success（成功） // 请求正常处理完毕3xx \\&gt; Redirection（重定向） // 需要进行附加操作以完成请求4xx \\&gt; Client Error（客户端错误） // 服务器无法处理请求5xx \\&gt; Server Error（服务器错误） // 服务器处理请求出错 速查 2xx（成功） 123200 OK // 处理好了，内容给你，用GET我就给你内容，HEAD不给204 No Content // 处理好了，内容就不返回了206 Partial Content // 这是你要的内容块 3xx（重定向） 12345301 Moved Permanently // 链接永久改了302 Found // 链接临时改了303 See Other // 链接临时改了,请用GET请求资源304 Not Modified // 找不到满足你条件的内容307 Temporary Redirect // 链接临时改了 4xx（客户端） 1234400 Bad Request // 语法错401 Unauthorized // 要登陆403 Forbidden // 我拒绝404 Not Found // 找不到 5xx（服务端） 12500 Internal Server Error // 我在执行请求的时候出错了503 Service Unavailable // 我在停机维护或CPU已爆表 结语 说明 HTTP状态码有时会不可靠。Web应用程序内部发生错误，依旧返回200。 参考 图解HTTP 延伸 HTTP状态码302、303和307的故事 - 烛秋@博客园 标准 RFC2616 WebDAV RFC4918 RFC5842 RFC6585 （附加HTTP状态码）","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://bergwhite.github.io/tags/HTTP/"}]},{"title":"传输层协议TCP和UDP","date":"2016-12-08T04:27:20.000Z","path":"2016/12/08/传输层协议TCP和UDP/","text":"TCP 三次握手 三次握手是发生在建立连接的时候，大致过程是这样的。首先由客户端发起请求，然后服务端对请求进行响应，最后客户端再告知收到响应。具体的过程列在了下面。 > 客户端发送带SYN标志的数据包给对方，告知需要建立连接； > 服务端收到后，回传一个带有SYN/ACK标志的数据包，告知收到建立连接请求； > 客户端回传一个带有ACK标志的数据包，代表握手结束并且建立TCP连接。 四次挥手 四次挥手则是在断开连接的时候，过程如下。 > 客户端发送带FIN标志的数据包给对方，告知需要断开连接； > 服务端收到后，回传一个带有ACK标志的数据包，告知收到断开连接请求； > 服务端再次回传一个带有FIN标志的数据包，告知同意断开连接请求； > 客户端回传一个带有ACK标志的数据包，代表挥手结束并且断开TCP连接。 UDPUDP没有类似TCP的三次握手机制，而是直接把数据发送出去。因此传输不具备可靠性。但是在网络极差的时候，凭借其不需要三次握手和四次挥手特性，却能高效的把数据传输出去。 词汇现在把上面出现的词汇分类整理一下吧。 传输协议 TCP - Transmission Control Protocol - 传输控制协议 UDP - User Datagram Protocol - 用户数据协议 握手状态 SYN - synchronous - 建立连接 ACK - acknowledgement - 确认收到 挥手状态 FIN - final - 关闭连接 参考这篇文章是我的读书笔记。综合了书中的知识以及参考了百度百科关于四次挥手的解释，总结出了对传输层协议TCP和UDP的浅显认知。其中，词汇的命名参考了园友azraelly的TCP的状态一文。 关于TCP和UDP的应用场景，以及在传输时都带有那些状态和数据，文中都没有提及。改日有时间再专门写一篇这样的文章。 [0] 图解HTTP [1] 四次挥手 [2] TCP的状态 (SYN, FIN, ACK, PSH, RST, URG)","tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://bergwhite.github.io/tags/HTTP/"}]}]